{"meta":{"title":"Hexo","subtitle":null,"description":"仰面朝天，知此身渺渺，沧海一粟","author":"刘奶奶找牛奶奶买榴莲牛奶","url":"https://github.com/RShit","root":"/"},"pages":[{"title":"分类","date":"2019-05-29T02:18:26.000Z","updated":"2019-05-29T02:21:56.121Z","comments":false,"path":"categories/index.html","permalink":"https://github.com/RShit/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-05-29T02:17:55.000Z","updated":"2019-05-29T02:21:44.683Z","comments":false,"path":"tags/index.html","permalink":"https://github.com/RShit/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"远程通讯协议-tcp/ip及nio的学习笔记","slug":"程通讯协议-tcp-ip及nio的学习笔记","date":"2019-07-17T09:39:19.000Z","updated":"2019-07-17T09:44:08.311Z","comments":true,"path":"2019/07/17/程通讯协议-tcp-ip及nio的学习笔记/","link":"","permalink":"https://github.com/RShit/2019/07/17/程通讯协议-tcp-ip及nio的学习笔记/","excerpt":"","text":"tcp 7层 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 4层网络模型： 其中应用层、表示层、会话层表示应用层，数据链路层、物理层表示网络接口层 ARP协议复杂的程序都需要分层，软件开发设计必须要做的 tcp负载均衡二层负载 -&gt; mac地址，vip(虚拟ip) 多个机器IP相同但是mac地址不同 三层负载 -&gt;ip 对外提供虚拟ip，集群中不同机器采用不用的ip，IP请求转发 四层负载 -&gt; 传输层负载，包含ip和端口，修改目标ip和端口地址 七层负载 -&gt; 应用层负载，请求的url，http请求的报文，如http://a/a.html,主机名。 tcp和udp区别TCP/IP：可靠 建立连接机制 三次握手建立连接 client发送请求连接的数据包 server返回可以进行连接的数据包 client发送确认请求连接的数据包 client/server可以进行数据传输了 SYNC攻击 -&gt; 客户端伪造大量ip和mac地址发送消息给服务器，占用服务器大量资源 连接的关闭，四次挥手协议 client发送请求关闭连接的数据包 server返回确认收到请求关闭的数据包-此时server可能还处于数据操作的状况 server数据已经处理完毕，并返回可以关闭的数据包 client返回最终请求关闭数据包-此时server接收到数据包以后将处于关闭状态,而client可能还处于数据为未接受完的状态，等待2个固定的时间点后进入关闭状态 TCP是一种全双工的协议 长连接，正常连接是超时关闭，但是长连接可以发送心跳包维持连接 UDP/IP：不可靠 在应用中如何去构建一个传输的实例socket -&gt; 套接字 socket io file io 通讯过程中的阻塞accept阻塞(连接阻塞) 流操作的阻塞(read/write) 滑动窗口的协议流量控制BIO模型 ​ blocker io 阻塞 优化方案： 可以解决socket io阻塞，但是还是存在file io阻塞问题 123456789101112131415ServerSocket server = new ServerSocket(8080);while(true) &#123; Socket socket = server.accpet(); new Thread(new SocketThread(socket)).start;&#125;public class SocketThread implements Runnable&#123; Socket socket; public SocketThread(Socket socket) &#123; this.socket = socket; &#125; public void run() &#123; // 对socket进行操作 &#125;&#125; NIO非阻塞 ​ new io / non blocker io 多路复用机制 linux fd：linux系统中一切皆可看成是文件，文件描述符是内核为了高效管理已被打开的文件所创建的索引 serverSocket 向请求内核 先监听socket/fd，再如果发现socket/fd已就绪，就发送数据已经准备好的通知(即可以像该文件进行读写)，然后serverSocket再来发送read/write请求 linux提供的io复用机制 select/poll：轮询查询socket/fd是否已经就绪 epoll：事件机制，理解为注册监听机制，如果发现socket/fd就绪直接返回就绪通知，可以进行读写 服务端的机器怎么去标记一个个的连接四元组：source_ip/source_port/target_ip/target_port 因为目标机器的ip和端口固定，所以最大连接数取决于客户端的数量 source_ip : 2^32 source_port:2^16 因为0不能作为端口，所以是65535个 内存大小 文件句柄的限制 ulimit -n 默认是1024 带宽的资源5.","categories":[],"tags":[],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"java8 新特性","slug":"java8-lambda语法","date":"2019-07-11T04:01:00.000Z","updated":"2019-07-11T06:13:29.544Z","comments":true,"path":"2019/07/11/java8-lambda语法/","link":"","permalink":"https://github.com/RShit/2019/07/11/java8-lambda语法/","excerpt":"","text":"jdk1.8 时间的创建及工具类1234567891011121314151617181920212223242526272829303132333435// ClockClock clock = Clock.systemDefaultZone();System.out.println(clock.millis());Instant instant = clock.instant();System.out.println(instant);Date from = Date.from(instant);System.out.println(from);// 时区// 获取所有时区Set&lt;String&gt; availableZoneIds = ZoneId.getAvailableZoneIds();System.out.println(availableZoneIds);// 获取指定时区的ZoneIdZoneId of = ZoneId.of(\"Asia/Aden\");System.out.println(of.getRules());// localtime 获取指定时区的时间LocalTime now = LocalTime.now(of);System.out.println(\"当前时间是：\"+now);// localData 本地日期LocalDate today = LocalDate.now();System.out.println(\"今天的日期是：\"+today);LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);System.out.println(\"明天的日期是：\"+tomorrow);LocalDate yesterday = today.plus(-1, ChronoUnit.DAYS);System.out.println(\"昨天的日期是：\"+yesterday);// 创建指定日期LocalDate of1 = LocalDate.of(2019, Month.JUNE, 11);System.out.println(of1);DayOfWeek dayOfWeek = of1.getDayOfWeek();System.out.println(\"今天是周几：\"+dayOfWeek);// DateTimeFormatter格式化时间DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy年MM月dd日\");String format = formatter.format(today);System.out.println(format); Stream12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970List&lt;String&gt; stringList = new ArrayList&lt;&gt;();stringList.add(\"ddd2\");stringList.add(\"aaa2\");stringList.add(\"bbb1\");stringList.add(\"aaa1\");stringList.add(\"bbb3\");stringList.add(\"ccc\");stringList.add(\"bbb2\");stringList.add(\"ddd1\");// stream 串行// 过滤stringList .stream() .filter(s -&gt; s.startsWith(\"a\")) .forEach(System.out::println);System.out.println(\"-----------------------\");// 排序// 排序只是创建了一个排序好的stream，原数据并没有改变stringList .stream() .sorted() .filter(s -&gt; s.startsWith(\"a\")) .forEach(System.out::println);System.out.println(\"-----------------------\");// map映射,map操作stringList .stream() .map(String::toUpperCase) .sorted((o1, o2) -&gt; o2.compareTo(o1)) .forEach(System.out::println);System.out.println(\"-----------------------\");// 匹配，任一一个匹配就可以返回boolean anyMatch = stringList .stream() .anyMatch(s -&gt; s.startsWith(\"a\"));System.out.println(anyMatch);System.out.println(\"-----------------------\");// 匹配，所有匹配，所有匹配到才会返回trueboolean allMatch = stringList .stream() .allMatch(s -&gt; s.startsWith(\"a\"));System.out.println(allMatch);System.out.println(\"-----------------------\");// 匹配,没有匹配到的返回true，如果有匹配到的则返回falseboolean noneMatch = stringList .stream() .noneMatch(s -&gt; s.startsWith(\"a\"));System.out.println(noneMatch);System.out.println(\"-----------------------\");// 计数long count = stringList .stream() .filter(s -&gt; s.startsWith(\"a\")) .count();System.out.println(count);System.out.println(\"-----------------------\");// 规约,将集合整合为一个元素Optional&lt;String&gt; reduce = stringList .stream() .sorted() .reduce((s, s2) -&gt; s + \"#\" + s2);reduce.ifPresent(System.out::println); lambda语法创建接口1234567891011public interface InteTest &#123; void initData(String string);&#125;public class Test &#123; public static void main(String[] args) &#123; InteTest inteTest = string -&gt; &#123; System.out.println(string); &#125;; inteTest.initData(\"123\"); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://github.com/RShit/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/RShit/tags/java/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"微服务及SpringCloud的一些面试问题","slug":"务及SpringCloud的一些面试问题","date":"2019-07-02T07:47:00.000Z","updated":"2019-07-03T06:17:59.538Z","comments":true,"path":"2019/07/02/务及SpringCloud的一些面试问题/","link":"","permalink":"https://github.com/RShit/2019/07/02/务及SpringCloud的一些面试问题/","excerpt":"","text":"soa和微服务的区别 soa:面向服务的框架，着重于将应用系统根据不同的业务模块拆分不同的服务，并通过这些服务定义好的接口联系起来。它是一种粗粒度，松耦合的框架，主要解决的是服务重复性问题。 微服务:微服务是soa架构下的最终产物，它相对soa来说对系统的拆分更加彻底，拆分粒度更细，拆分后的服务都可以单独的运行。微服务主要解决的是服务的高耦合问题，通过降低服务之间的耦合度来把服务分割的更彻底，每个服务都可以不依赖于其他服务而独立运行，当一个服务出问题时，对其他服务并不会造成影响。 soa和微服务都是分布式的具体实现思想。 你是怎么理解微服务的？ 微服务顾名思义就是将系统拆分为一个个可以独立部署、水平扩展、独立运行的细微服务。 使用微服务的思想通过对单体架构的系统进行细粒度的拆分，从而降低各个服务之间的耦合度，单个服务中如果出现问题而不会对其他服务产生影响。并且通过对系统的拆分，会极大的解决原单体架构系统中的有些业务运行速度过慢而对其他业务造成的影响。 什么是SpringCloud SpringCloud可以通俗的理解为整合各个分布式基础设施的工具箱，它是一系列框架的有序集合，注重于服务治理。 微服务架构的优点和缺点有哪些？ 微服务的主要作用是大型业务系统进行细粒度的拆分，从而降低项目开发时某一模块的开发对其他模块业务开发的影响，可以将项目中的各个模块更快地上线落地，相对传统的单体架构中一块出问题其他都会被影响，微服务带来的是更加敏捷的更新维护，当其中一个服务出问题时，其他服务不会受到影响。但是当系统拆分的太细致，造成的运维成本也相对的更大，梳理各服务的功能调用逻辑更麻烦，本来只需要对一个系统的维护现在变相的变成对多个系统的维护，这样的成本会大大的增大。 SpringCloud解决了什么问题？ SpringCloud利用SpringBoot的开发便利性简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、熔断器、数据监控、负载均衡等，都可以利用SpringBoot的开发风格做到一键部署和启动。","categories":[{"name":"java","slug":"java","permalink":"https://github.com/RShit/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/RShit/tags/java/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://github.com/RShit/tags/SpringCloud/"},{"name":"微服务","slug":"微服务","permalink":"https://github.com/RShit/tags/微服务/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"java并发编程-volatile关键字","slug":"latile","date":"2019-06-26T08:16:00.000Z","updated":"2019-06-26T09:36:14.152Z","comments":true,"path":"2019/06/26/latile/","link":"","permalink":"https://github.com/RShit/2019/06/26/latile/","excerpt":"","text":"并发编程MESI协议基于失效的缓存一致性协议 有四个状态: Exclusive(E)：独享，其他缓存都没有有效的副本 Shared(S)：共享，其他缓存都有有效的副本 Invalid(I)：失效 Modified(M)：修改 原子性、有序性、可见性原子性在java中，对基本数据类型的变量读取和赋值操作是原子性操作，这些操作是不可中断的，也就是要么读，要么不读，或者要么写要么不写。 1234x = 10; // 操作1y = x; // 操作2x++; // 操作3x = x + 1;//操作4 以上的操作中只有操作1属于原子性操作。 有序性有以下这样的代码：12345678910111213int x = 10;//volatile int x = 10; 如果x有volatile关键字修饰时,就可以保证有序性void cpu0()&#123; x = 100;// 此时x的状态变幻情况为：S(共享) -&gt; M(修改),此时通过cpu0会通知其他cpu的x的值为I(失效)，再取出最新值，会消耗一段时间才会将x的值修改完成 flag = true;// 当flag此时是E状态时，变化状态:E(独享) -&gt; M(修改)，此时flag的值会直接修改，并发送给其他cpu状态置为S(共享)&#125;void cpu1()&#123; while(flag) &#123; System.out.println(x == 100); &#125;&#125; 当有volatile关键字修饰时，会看到在程序运行时的汇编指令中会发现有locak指令，相当于一个内存屏障，会强制把缓存的操作写入主存。 当不能保证有序性时，打印输出的结果可能为false。所以在程序运行必须保证有序性。 可见性在Java中，提供了volatile关键保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。此外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。 volatile、synchronizedvolatile可以保证对变量操作的有序性、可见性，但是不能保证原子性 synchronized可以保证对变量的有序性、可见性、原子性","categories":[{"name":"java","slug":"java","permalink":"https://github.com/RShit/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/RShit/tags/java/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"linux的5种io模型","slug":"nux的5中io模型","date":"2019-06-11T10:27:00.000Z","updated":"2019-06-12T01:26:41.349Z","comments":true,"path":"2019/06/11/nux的5中io模型/","link":"","permalink":"https://github.com/RShit/2019/06/11/nux的5中io模型/","excerpt":"","text":"linux的5种io模型阻塞式io非阻塞式io信号驱动式ioio复用模式异步io","categories":[{"name":"linux","slug":"linux","permalink":"https://github.com/RShit/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://github.com/RShit/tags/linux/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"URL与URI的区别","slug":"RL与URI的区别","date":"2019-06-05T08:20:36.000Z","updated":"2019-07-10T03:55:46.779Z","comments":true,"path":"2019/06/05/RL与URI的区别/","link":"","permalink":"https://github.com/RShit/2019/06/05/RL与URI的区别/","excerpt":"","text":"定义URL 统一资源定位符 示例:http://localhost:8081/spring/demo/query?name=1 URI 统一资源标识符 示例:/spring/demo/query","categories":[],"tags":[],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"Arrays.asList()的使用","slug":"代码示例","date":"2019-05-29T02:44:00.000Z","updated":"2019-07-11T04:11:07.461Z","comments":true,"path":"2019/05/29/代码示例/","link":"","permalink":"https://github.com/RShit/2019/05/29/代码示例/","excerpt":"","text":"Arrays.asList()的使用代码：12345678910111213141516171819202122232425262728293031323334353637383940public class ArraysToListTest &#123; public static void main(String[] args) &#123; int[] nums = &#123;1,2,3,4,5&#125;; printArrays(nums); List&lt;int[]&gt; ints = Arrays.asList(nums); printArrays(ints); Integer[] integers = &#123;1,2,3,4,5&#125;; printArrays(integers); List&lt;Integer&gt; integerList = Arrays.asList(integers); printArrays(integerList); &#125; public static void printArrays(List list)&#123; list.forEach(o -&gt; &#123; if (o instanceof int[]) &#123; printArrays((int[]) o); &#125;else &#123; System.out.println(o); &#125; &#125;); System.out.println(); &#125; public static void printArrays(Integer[] nums)&#123; for (int i = 0; i &lt; nums.length; i++) &#123; int num = nums[i]; System.out.print(num+\" \"); &#125; System.out.println(); &#125; public static void printArrays(int[] nums)&#123; for (int i = 0; i &lt; nums.length; i++) &#123; int num = nums[i]; System.out.print(num+\" \"); &#125; System.out.println(); &#125;&#125; 总结： 当使用Arrays.asList(nums);转换的数组内容为基本数据类型时，转换后的list集合的存放的也是这个基本数据类型的数组，而不是这个基本数据类型的值。 如果要对转换后的list进行增删改操作，则需要以new的方式来创建list 解决方法：使用其包装类型: 12Integer[] integers = &#123;1,2,3,4,5&#125;;List&lt;Integer&gt; integerList = new ArrayList&lt;&gt;(Arrays.asList(integers));","categories":[{"name":"java","slug":"java","permalink":"https://github.com/RShit/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/RShit/tags/java/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"单例模式的基础知识","slug":"模式","date":"2019-05-29T01:28:00.000Z","updated":"2019-07-02T07:53:23.690Z","comments":true,"path":"2019/05/29/模式/","link":"","permalink":"https://github.com/RShit/2019/05/29/模式/","excerpt":"","text":"单例模式单例模式的优缺点优点 内存消耗小 全局只有一个实例 缺点 没有接口，扩展困难 如果要扩展单例，只能修改代码 创建单例的方法饿汉式模式 直接创建-消耗内存-线程不安全 静态创建-线程不安全 懒汉式模式 判断为空再创建-线程不安全 双重检验为空再创建 使用synchronize关键字-线程安全 静态内部类创建-线程安全 注册式创建 简单注册-spring 枚举类创建 序列化线程池关于单例模式的问题spring的单例会被回收吗？ 注册式单例，被保存在ioc的缓存容器中，给每个实例起个名字，叫beanName、id ioc容器持有单例对象的引用 当对象为null或引用不被任何地方所持有时会被回收 ioc容器本身也是个单例，ioc容器什么时候被回收，那么ioc中的beanName也就什么时候被回收 ioc容器实在spring启动时初始化，在spring销毁时被回收 spring中的单例Bean跟ioc容器同生死 spring的单例是线程安全的吗？ 它由在beanFactory中由反射机制创建，被缓存到ioc容器中，相当于new Object() 所以他是线程安全的","categories":[{"name":"java","slug":"java","permalink":"https://github.com/RShit/categories/java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/RShit/tags/设计模式/"},{"name":"单例模式","slug":"单例模式","permalink":"https://github.com/RShit/tags/单例模式/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"Java Integer(-128~127)值的==和equals比较","slug":"va-Integer-128-127-值的-和equals比较","date":"2019-05-29T01:28:00.000Z","updated":"2019-06-12T07:40:45.161Z","comments":true,"path":"2019/05/29/va-Integer-128-127-值的-和equals比较/","link":"","permalink":"https://github.com/RShit/2019/05/29/va-Integer-128-127-值的-和equals比较/","excerpt":"","text":"Integer有如下代码： 123456789101112131415161718192021222324Integer i1 = 127;Integer i2 = 127;System.out.print(i1+\" == \"+i2+\" :\"+(i1 == i2));System.out.println(\" \"+i1+\".equals(\"+i2+\") :\"+(i1.equals(i2)));Integer i3 = 128;Integer i4 = 128;System.out.print(i3+\" == \"+i4+\" :\"+(i3 == i4));System.out.println(\" \"+i3+\".equals(\"+i4+\") :\"+(i3.equals(i4)));Integer i5 = new Integer(127);Integer i6 = new Integer(127);System.out.print(i5+\" == \"+i6+\" :\"+(i5 == i6));System.out.println(\" \"+i5+\".equals(\"+i6+\") :\"+(i5.equals(i6)));Integer i7 = new Integer(128);Integer i8 = new Integer(128);System.out.print(i7+\" == \"+i8+\" :\"+(i7 == i8));System.out.println(\" \"+i7+\".equals(\"+i8+\") :\"+(i7.equals(i8)));Integer i9 = new Integer(40);Integer i10 = new Integer(40);Integer i11 = new Integer(0);System.out.println(\"i9=i10+i11 \" + (i9 == i10 + i11)); 输出结果如下： 12345127 == 127 :true 127.equals(127) :true128 == 128 :false 128.equals(128) :true127 == 127 :false 127.equals(127) :true128 == 128 :false 128.equals(128) :truei9=i10+i11 true 总结: 在-128~127的Integer值如果以Integer x = value;的方式赋值的Integer值在进行==和equals比较时，都会返回true 在-128~127之外的以Integer x = value;的方式赋值的Integer值在进行==和equals比较时，返回结果并不下相同 无论是在-128~127还是之外的Integer值如果以Integer x = new Integer(value);的方式赋值的Integer值在进行==和equals比较时,返回结果都并不x相同 因为Java里面对处在在-128~127之间的使用Integer x = value;赋值的Integer值，用的是原生数据类型int，会在内存里供重用，也就是说这之间的Integer值进行==比较时只是进行int原生数据类型的数值比较，而超出-128~127的范围，进行==比较时是进行地址及数值比较。 而对于所有以Integer x = new Integer(value);赋值的Integer值，使用== 比较时是进行地址及数值比较。 语句 i9 == i10 + i11，因为+这个操作符不适用于 Integer 对象，首先 i10 和 i11 进行自动拆箱操作，进行数值相加，即 i9 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i9 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较 所以在比较包装类型的值时，必须使用equals进行比较","categories":[{"name":"java","slug":"java","permalink":"https://github.com/RShit/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/RShit/tags/java/"},{"name":"Integer","slug":"Integer","permalink":"https://github.com/RShit/tags/Integer/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"markdown特殊语法","slug":"arkdown特殊语法","date":"2019-05-22T09:49:00.000Z","updated":"2019-05-30T04:30:12.154Z","comments":true,"path":"2019/05/22/arkdown特殊语法/","link":"","permalink":"https://github.com/RShit/2019/05/22/arkdown特殊语法/","excerpt":"","text":"插入图片1&#123;% asset_img clipboard.png 图片1 %&#125;","categories":[{"name":"工具","slug":"工具","permalink":"https://github.com/RShit/categories/工具/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://github.com/RShit/tags/markdown/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"linux命令","slug":"linux命令","date":"2019-05-15T09:52:00.000Z","updated":"2019-05-29T02:05:52.421Z","comments":true,"path":"2019/05/15/linux命令/","link":"","permalink":"https://github.com/RShit/2019/05/15/linux命令/","excerpt":"","text":"linux命令上传-下载文件上传和下载文件使用rz和sz命令 使用以下命令安装rz和sz： 1yum install -y lrzsz 上传输入以下命令： 1rz 打开选择文件窗口选择文件即可上传 下载输入以下命令：1sz 文件名 打开文件要下载的地址选择路径下载即可 ssh传输文件123scp test.zip admin@192.168.1.1:/test解析：scp 文件名 ssh地址:要复制的文件到远程机的路径 vi编辑器1234567891011121314151617181920212223242526272829303132333435打开文件：vi test.txtCtrl+u：向文件首翻半屏；Ctrl+d：向文件尾翻半屏；Ctrl+f：向文件尾翻一屏；Ctrl+b：向文件首翻一屏；Esc：从编辑模式切换到命令模式；ZZ：命令模式下保存当前文件所做的修改后退出vi；:行号：光标跳转到指定行的行首；:$：光标跳转到最后一行的行首；x或X：删除一个字符，x删除光标后的，而X删除光标前的；D：删除从当前光标到光标所在行尾的全部字符；dd：删除光标行正行内容；ndd：删除当前行及其后n-1行；nyy：将当前行及其下n行的内容保存到寄存器？中，其中？为一个字母，n为一个数字；p：粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的下方；P：粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的上方；/字符串：文本查找操作，用于从当前光标所在位置开始向文件尾部查找指定字符串的内容，查找的字符串会被加亮显示；？字符串：文本查找操作，用于从当前光标所在位置开始向文件头部查找指定字符串的内容，查找的字符串会被加亮显示；a，bs/F/T：替换文本操作，用于在第a行到第b行之间，将F字符串换成T字符串。其中，“s/”表示进行替换操作；a：在当前字符后添加文本；A：在行末添加文本；i：在当前字符前插入文本；I：在行首插入文本；o：在当前行后面插入一空行；O：在当前行前面插入一空行；:wq：在命令模式下，执行存盘退出操作；:w：在命令模式下，执行存盘操作；:w！：在命令模式下，执行强制存盘操作；:q：在命令模式下，执行退出vi操作；:q！：在命令模式下，执行强制退出vi操作；:e文件名：在命令模式下，打开并编辑指定名称的文件；:n：在命令模式下，如果同时打开多个文件，则继续编辑下一个文件；:f：在命令模式下，用于显示当前的文件名、光标所在行的行号以及显示比例；:set number：在命令模式下，用于在最左端显示行号；:set nonumber：在命令模式下，用于在最左端不显示行号；","categories":[{"name":"linux","slug":"linux","permalink":"https://github.com/RShit/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://github.com/RShit/tags/linux/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"动态壁纸","slug":"壁纸","date":"2019-05-15T07:47:00.000Z","updated":"2019-05-29T02:09:29.284Z","comments":true,"path":"2019/05/15/壁纸/","link":"","permalink":"https://github.com/RShit/2019/05/15/壁纸/","excerpt":"","text":"动态壁纸软件 Wallpaper Engine","categories":[{"name":"工具","slug":"工具","permalink":"https://github.com/RShit/categories/工具/"}],"tags":[{"name":"壁纸工具","slug":"壁纸工具","permalink":"https://github.com/RShit/tags/壁纸工具/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"opencv参考链接","slug":"pencv参考链接","date":"2019-05-06T09:18:00.000Z","updated":"2019-05-29T02:09:39.015Z","comments":true,"path":"2019/05/06/pencv参考链接/","link":"","permalink":"https://github.com/RShit/2019/05/06/pencv参考链接/","excerpt":"","text":"基于java的opencv、tesseractc参考链接 Intellij Idea 部署 OpenCV-4.0.0 环境 如何使用Tesseract和OpenCV执行OCR和文本识别 tesseract官方文档 OpenCV Java Tutorials documentation! Tesseract-OCR识别中文与训练字库实例 Tesseract-OCR识别中文与训练字库实例","categories":[{"name":"人工识别","slug":"人工识别","permalink":"https://github.com/RShit/categories/人工识别/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/RShit/tags/java/"},{"name":"ocr","slug":"ocr","permalink":"https://github.com/RShit/tags/ocr/"},{"name":"oepncv","slug":"oepncv","permalink":"https://github.com/RShit/tags/oepncv/"},{"name":"testseract","slug":"testseract","permalink":"https://github.com/RShit/tags/testseract/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"git提交","slug":"it提交","date":"2019-05-06T09:15:00.000Z","updated":"2019-05-29T02:09:45.235Z","comments":true,"path":"2019/05/06/it提交/","link":"","permalink":"https://github.com/RShit/2019/05/06/it提交/","excerpt":"","text":"git提交步骤 git init //初始化仓库 git add .(文件name) //添加文件到本地仓库 git commit -m “first commit” //添加文件描述信息 git remote add origin + 远程仓库地址 //链接远程仓库，创建主分支 git pull origin master // 把本地仓库的变化连接到远程仓库主分支 git push -u origin master //把本地仓库的文件推送到远程仓库 强制提交如果确定代码无误，可以强制提交 git push -f 错误处理1fatal: refusing to merge unrelated histories 在merge、pull或push中出现以上错误，可以使用以下命令： 12345678merge时：git merge master --allow-unrelated-historiespull时：git pull origin master --allow-unrelated-historiespush时：git push -u origin master --allow-unrelated-histories","categories":[{"name":"工具","slug":"工具","permalink":"https://github.com/RShit/categories/工具/"}],"tags":[{"name":"git","slug":"git","permalink":"https://github.com/RShit/tags/git/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"html5 audio配合span data-src-mp3使用","slug":"ntitled","date":"2019-04-26T04:20:00.000Z","updated":"2019-05-29T02:09:56.881Z","comments":true,"path":"2019/04/26/ntitled/","link":"","permalink":"https://github.com/RShit/2019/04/26/ntitled/","excerpt":"","text":"html5 audio配合span data-src-mp3使用编写html代码12345&lt;audio id=\"player\" style=\"display: none\"&gt;&lt;/audio&gt;&lt;span class = '1' data-src-mp3=\"\" data-src-ogg=\"\"&gt;&lt;/span&gt; &lt;span class = '2' data-src-mp3=\"\" data-src-ogg=\"\"&gt;&lt;/span&gt; 初始化span标签123456$(\"span.1\") .attr(\"data-src-mp3\",\"song1.mp3\") .attr(\"data-src-ogg\",\"song1.ogg\");$(\"span.2\") .attr(\"data-src-mp3\",\"song2.mp3\") .attr(\"data-src-ogg\",\"song2.ogg\"); 控制播放1234567891011121314151617181920212223$(\"span[data-src-mp3]\").click(function () &#123; var player = document.getElementById(\"player\"), $this = $(this); if ($this.hasClass(\"selected\")) &#123; if (player.paused) &#123; player.play(); &#125; else &#123; player.pause(); &#125; &#125; else &#123; $(\"span[data-src-mp3].selected\").removeClass(\"selected\"); $this.addClass(\"selected\"); $(player) .empty() .append($(\"&lt;source&gt;\").attr(\"src\", $this.attr(\"data-src-mp3\"))) .append($(\"&lt;source&gt;\").attr(\"src\", $this.attr(\"data-src-ogg\"))) // 必须使用load重新加载audio，否则播放audio时，播放出来的还是最初始的资源 player.load(); player.play(); &#125;&#125;);","categories":[{"name":"html","slug":"html","permalink":"https://github.com/RShit/categories/html/"}],"tags":[{"name":"audio","slug":"audio","permalink":"https://github.com/RShit/tags/audio/"},{"name":"html5","slug":"html5","permalink":"https://github.com/RShit/tags/html5/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"SpringBoot项目基础搭建","slug":"ringBoot","date":"2019-03-15T01:54:00.000Z","updated":"2019-07-02T07:54:13.000Z","comments":true,"path":"2019/03/15/ringBoot/","link":"","permalink":"https://github.com/RShit/2019/03/15/ringBoot/","excerpt":"","text":"什么是spring bootSpring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。 — 来自百度百科 springboot 的特点 创建独立的Spring应用程序 嵌入的Tomcat，无需部署WAR文件 简化Maven配置 自动配置Spring 提供生产就绪型功能，如指标，健康检查和外部配置 绝对没有代码生成并且对XML也没有配置要求 使用spring boot有什么好处简单、快速、方便！平时如果我们需要搭建一个spring web项目的时候需要怎么做呢？ 1）配置web.xml，加载spring和spring mvc 2）配置数据库连接、配置spring事务 3）配置加载配置文件的读取，开启注解 4）配置日志文件 … 配置完成之后部署tomcat 调试 … 快速入门maven构建项目使用工具：IntelliJ IDEA 2018.3.4、jdk1.8.0_201 在idea界面点击 Create New project,然后点击Next 选择Spring Initializar点击Next 设置初始java包结构点击Next 在此步骤选择springboot集成的其他框架，如mysql然后点击Next 输入项目名称，点击finish即可完成创建springboot项目项目结构如下： src/main/java/: 程序开发及主程序入口 src/main/resources/: 配置文件 src/test: 测试程序 引入web模块1、在pom文件中添加web模块依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; pom.xml文件中默认有两个模块： spring-boot-starter：核心模块，包括自动配置支持、日志和YAML； spring-boot-starter-test：测试模块，包括JUnit、Hamcrest、Mockito。 2、编写 HelloWorldController1234567@RestControllerpublic class HelloWorldController &#123; @RequestMapping(\"/hello\") private String hello()&#123; return \"hello world\"; &#125;&#125; @RestController的意思就是controller里面的方法都以json格式输出. 3、启动主程序在浏览器打开http://127.0.0.1:8080/hello,即可看到结果 开发环境的调试springBoot对调试支持很好，修改之后可以实时生效，需要添加以下的配置： 12345678910111213141516171819&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 该模块在完整的打包环境下运行的时候会被禁用。如果你使用java -jar启动应用或者用一个特定的classloader启动，它会认为这是一个“生产环境”。","categories":[{"name":"springboot","slug":"springboot","permalink":"https://github.com/RShit/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://github.com/RShit/tags/springboot/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"excel数据处理","slug":"xcel数据处理","date":"2019-03-14T02:57:00.000Z","updated":"2019-05-29T02:10:13.339Z","comments":true,"path":"2019/03/14/xcel数据处理/","link":"","permalink":"https://github.com/RShit/2019/03/14/xcel数据处理/","excerpt":"","text":"excel中把一列数据中第一个空格前后的内容分为两列设原内容在A列，则12B1=LEFT(A1,FIND(&quot;&quot;,A1))C1=MID(A1,FIND(&quot;&quot;,A1)+1,LEN(A1)) 在一组数据中筛选包含另一组数据的某个数据的单元 使用MATCH(A2,$B$2:$B$13,0) 公式里第三个参数的含义： 返回结果为位置，如果只需要知道是否存在则可用： IF(MATCH(A2,$B$2:$B$13,0)&gt;0,TRUE)","categories":[{"name":"工具","slug":"工具","permalink":"https://github.com/RShit/categories/工具/"}],"tags":[{"name":"excel","slug":"excel","permalink":"https://github.com/RShit/tags/excel/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"mysql删除语句使用","slug":"sql","date":"2019-03-14T02:36:00.000Z","updated":"2019-06-12T06:22:19.022Z","comments":true,"path":"2019/03/14/sql/","link":"","permalink":"https://github.com/RShit/2019/03/14/sql/","excerpt":"","text":"mysql删除语句使用：1delete t from table_name t where t.id = 1","categories":[{"name":"数据库","slug":"数据库","permalink":"https://github.com/RShit/categories/数据库/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://github.com/RShit/tags/mysql/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"服务器桌面端差异","slug":"务器桌面端差异","date":"2019-03-14T02:35:00.000Z","updated":"2019-05-29T02:08:36.350Z","comments":true,"path":"2019/03/14/务器桌面端差异/","link":"","permalink":"https://github.com/RShit/2019/03/14/务器桌面端差异/","excerpt":"","text":"javax.net.ssl.SSLKeyException: RSA premaster secret error错误的解决办法： 找到jre环境的lib/ext/sunjce_provider.jar 把这个放到程序的lib下","categories":[{"name":"问题处理","slug":"问题处理","permalink":"https://github.com/RShit/categories/问题处理/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/RShit/tags/java/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"maven导出所有使用的jar包","slug":"ven","date":"2019-03-14T01:55:00.000Z","updated":"2019-06-12T06:22:28.620Z","comments":true,"path":"2019/03/14/ven/","link":"","permalink":"https://github.com/RShit/2019/03/14/ven/","excerpt":"","text":"maven导出所有使用的jar包: mvn dependency:copy-dependencies -DoutputDirectory=lib -DincludeScope=compile","categories":[{"name":"java","slug":"java","permalink":"https://github.com/RShit/categories/java/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://github.com/RShit/tags/maven/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"cmd运行java","slug":"d运行java","date":"2019-03-14T01:52:00.000Z","updated":"2019-05-29T02:10:50.924Z","comments":true,"path":"2019/03/14/d运行java/","link":"","permalink":"https://github.com/RShit/2019/03/14/d运行java/","excerpt":"","text":"用命令行编译运行带有包或使用外部jar包的情况12345编译：javac -Djava.ext.dirs=./lib Test.java 或 javac -Djava.ext.dirs=D:/javacode/lib运行：java -Djava.ext.dirs=./lib Test 将日志保存至文件中：java -Djava.ext.dirs=./lib Test &gt;&gt; log.txt","categories":[{"name":"java","slug":"java","permalink":"https://github.com/RShit/categories/java/"}],"tags":[{"name":"cmd","slug":"cmd","permalink":"https://github.com/RShit/tags/cmd/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"notepad++ 字符串匹配","slug":"tepad-字符串匹配","date":"2019-03-12T03:35:00.000Z","updated":"2019-05-29T02:11:05.730Z","comments":true,"path":"2019/03/12/tepad-字符串匹配/","link":"","permalink":"https://github.com/RShit/2019/03/12/tepad-字符串匹配/","excerpt":"","text":"匹配模式查找：a.+?da 表示查找以a开头a结尾的","categories":[{"name":"工具","slug":"工具","permalink":"https://github.com/RShit/categories/工具/"}],"tags":[{"name":"notepad++","slug":"notepad","permalink":"https://github.com/RShit/tags/notepad/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"python格式化字符串","slug":"python","date":"2019-03-12T03:33:00.000Z","updated":"2019-06-12T06:22:02.223Z","comments":true,"path":"2019/03/12/python/","link":"","permalink":"https://github.com/RShit/2019/03/12/python/","excerpt":"","text":"格式化字符串各符号表示：%d - 整数 %s - 字符串 %f - 浮点数 %x - 十六进制整数 实例print(&apos;%2d-%02d&apos; % (3, 1)) print(&apos;%.2f&apos; % 3.1415926) 解释： %后数字若为一位表示位数，如若两位，第一位是补充数字，第二位是位数 浮点数前加. %%表示转义为%","categories":[{"name":"python","slug":"python","permalink":"https://github.com/RShit/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/RShit/tags/python/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"windows特殊字符","slug":"ndows","date":"2019-03-12T03:24:00.000Z","updated":"2019-06-12T06:21:33.743Z","comments":true,"path":"2019/03/12/ndows/","link":"","permalink":"https://github.com/RShit/2019/03/12/ndows/","excerpt":"","text":"windows特殊字符版权符号：alt+169 © 拼音：版权 ©","categories":[{"name":"工具","slug":"工具","permalink":"https://github.com/RShit/categories/工具/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://github.com/RShit/tags/windows/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"docker&tomcat","slug":"cker-tomcat","date":"2019-03-12T03:08:00.000Z","updated":"2019-05-29T02:11:41.374Z","comments":true,"path":"2019/03/12/cker-tomcat/","link":"","permalink":"https://github.com/RShit/2019/03/12/cker-tomcat/","excerpt":"","text":"docker 简介 image(镜像)：对比iso镜像文件，不可操作，只能被pull下载下来使用或push将自己的镜像上传上去 container(容器): 对比iso镜像中的live cd模式，不用直接安装需要的东西即可直接使用。但是一旦容器关闭，那么在容器中安装的vim或gcc都将会被销毁。如果要保存这些，就需要将当前容器封装成自己的镜像。 repository(仓库)： 类似于git，既可以将自己在git上下载下来的代码上传上去，也可以将自己上传上去的代码下载下来。只需要有别人的镜像的名字，标签。自己也可以将自己的镜像设置为私有。 docker 启动和停止1234停止当前tomcat应用：docker-compose down启动tomcat应用：docker-compose up -d docker compose映射端口将容器的8000端口映射到宿主机上的7001端口: docker compose run -p 7001:8000 web python a.py runserver 0.0.0.0:8000 使用-p命令映射端口后，访问web应用需访问宿主机的端口7001 启动注意docker compose run启动一个容器时，如果service中有--link指定的其他服务没有运行，会先运行这些服务，–link依赖的这些服务都运行后，才会执行指定的命令。如果不想启动依赖的其他服务，可以使用--no-deps标识。docker compnse run --no-deps web python manage.py shell","categories":[{"name":"java","slug":"java","permalink":"https://github.com/RShit/categories/java/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://github.com/RShit/tags/docker/"},{"name":"tomcat","slug":"tomcat","permalink":"https://github.com/RShit/tags/tomcat/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"jfinal 文件上传特殊处理","slug":"inal","date":"2019-03-12T03:07:00.000Z","updated":"2019-06-12T06:21:18.678Z","comments":true,"path":"2019/03/12/inal/","link":"","permalink":"https://github.com/RShit/2019/03/12/inal/","excerpt":"","text":"jfinal 文件上传特殊处理如果页面中form中有enctype=&quot;multipart/form-data&quot;属性，在后台接收数据时先使用getFile，再使用getPara();","categories":[{"name":"java","slug":"java","permalink":"https://github.com/RShit/categories/java/"}],"tags":[{"name":"jfinal","slug":"jfinal","permalink":"https://github.com/RShit/tags/jfinal/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"js特殊用法","slug":"js特殊用法","date":"2019-03-12T03:00:00.000Z","updated":"2019-06-04T01:45:02.763Z","comments":true,"path":"2019/03/12/js特殊用法/","link":"","permalink":"https://github.com/RShit/2019/03/12/js特殊用法/","excerpt":"","text":"jquery获取jsonJS里使用 $!{string} 获取原格式的字符串； 出现此种错误时，将${} 改为$!{} 使用 js 动态元素选择器123var i=1;var head=\"head\"+i;$(\"#head\"+head+\"\"); 使用js处理双击、选中事件jquery 处理方式1$(document.body).on('mouseup',\"#content\",mouseUp); dom处理方式：1document.addEventListener(\"dblclick\", doubleClick, true); 释放鼠标处理函数123456789101112function mouseUp() &#123; var text = \"\"; if (window.getSelection) &#123; text = window.getSelection().toString(); &#125; else if (document.selection &amp;&amp; document.selection.type != \"Control\") &#123; text = document.selection.createRange().text; &#125; if (\"\" != text&amp;&amp;\" \" != text) &#123; $(\"#checkText\").val(text); layer.msg(text); &#125;&#125; js计算1234parseInt(5/2); 结果：2 舍弃小数部分，取整数Math.ceil(5/2); 结果：3 向上取整，有小时就整数加一Math.round(5/2);结果：3 四舍五入Math.floor(5/2);结果：2 向下取整 js给指定一篇文章添加行号123456789101112131415161718192021222324252627282930313233343536373839404142434445function getLineNum()&#123;var $lineNum=$(\"#lineNum\");$lineNum.empty();var rowNum=Math.round(document.getElementById(\"contentT\").scrollHeight/parseFloat($(\"#contentT\").css(\"line-height\")));console.log(\"$('.article fl').height():\"+document.getElementById(\"contentT\").scrollHeight);console.log(\"parseFloat($('.article fl').css('line-height')):\"+parseFloat($(\"#contentT\").css(\"line-height\")));console.log(rowNum);for(var i=1;i&lt;rowNum;i++)&#123; var flag=false; if(headNum&gt;1)&#123; for(var j=2;j&lt;=headNum;j++)&#123; var headId=\"head\"+j; var $headEle=$(\"#\"+headId+\"\"); var offsetTop=$headEle.position().top; var headRow=Math.round(offsetTop/parseFloat($(\"#contentT\").css(\"line-height\"))); headRow=headRow+1; if(headRow==i)&#123; flag=true; break; &#125; &#125; &#125; if(flag)&#123; if(i%5==0||i==1)&#123; $lineNum.append(\"&lt;br&gt;&lt;p&gt;\"+i+\"&lt;/p&gt;\"); &#125;else&#123; $lineNum.append(\"&lt;br&gt;&lt;br&gt;\"); &#125; &#125;else&#123; if(i%5==0)&#123; $lineNum.append(\"&lt;p&gt;\"+i+\"&lt;/p&gt;\"); &#125;else if(i==1)&#123; $lineNum.append(\"&lt;p&gt;\"+i+\"&lt;/p&gt;\"); &#125;else&#123; $lineNum.append(\"&lt;br&gt;\"); &#125; &#125;&#125;&#125;; js对象转换jquery对象dom对象dom对象转换为jquery对象：12var d=document.getElementById(\"id\"); //对象d为DOM对象var s=$(d); //对象s为Jquery对象 jquery对象转换为dom对象：123var d=document.getElementById(\"id\"); //对象d为DOM对象var s=$(d); //对象s为Jquery对象var dd=s.get(0) //对象dd为DOM对象 js随机打乱数组 123456function randomsort(a, b) &#123; return Math.random()&gt;.5 ? -1 : 1; //用Math.random()函数生成0~1之间的随机数与0.5比较，返回-1或1&#125;var arr = [1, 2, 3, 4, 5];arr.sort(randomsort); js从数组中获取指定个数的随机数据12345678910111213141516/** * 从数组中随机取指定数量的数据 * @param arr 数据 * @param count 随机数量 * @returns &#123;*&#125; */function getRandomArrayElements(arr, count) &#123; var shuffled = arr.slice(0), i = arr.length, min = i - count, temp, index; while (i-- &gt; min) &#123; index = Math.floor((i + 1) * Math.random()); temp = shuffled[index]; shuffled[index] = shuffled[i]; shuffled[i] = temp; &#125; return shuffled.slice(min);&#125; js禁止双击1&lt;body onselectstart = &quot;return false&quot; style = &#123; -moz-user-select : none &#125;&gt;&lt;/body&gt; js控制div里的滚动条12$('.dtcon').animate(&#123;scrollTop:'0px'&#125;, 200);200:滚动条移动至指定位置所需时间 ms","categories":[{"name":"html","slug":"html","permalink":"https://github.com/RShit/categories/html/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/RShit/tags/JavaScript/"}]},{"title":"form表单外不同的按钮提交到不同的url","slug":"html","date":"2019-03-08T07:24:00.000Z","updated":"2019-06-12T06:21:04.469Z","comments":true,"path":"2019/03/08/html/","link":"","permalink":"https://github.com/RShit/2019/03/08/html/","excerpt":"","text":"form表单外不同的按钮提交到不同的url1234567891011121314151617181920&lt;form hidden=\"\" id=\"form\" method=\"post\"&gt; &lt;input type=\"text\" value=\"\" name=\"rel\" id=\"rel\"&gt; &lt;input type=\"text\" value=\"\" name=\"answer\" id=\"answer\"&gt; &lt;input type=\"text\" value=\"\" name=\"curPage\" id=\"curPage\"&gt; &lt;input type=\"text\" value=\"\" name=\"examName\" id=\"examName\"&gt;&lt;/form&gt;&lt;button typr='button' id='but1' class='but1'&gt;&lt;/button&gt;&lt;button typr='button' id='but2' class='but2'&gt;&lt;/button&gt;&lt;script&gt; $(document).on('click','button.but1',function()&#123; $(\"#form\").attr(\"action\",\"url\"); $(\"#form\").submit(); &#125;) $(document).on('click','button.but1',function()&#123; $(\"#form\").attr(\"action\",\"url\"); $(\"#form\").submit(); &#125;)&lt;/script&gt;","categories":[{"name":"html","slug":"html","permalink":"https://github.com/RShit/categories/html/"}],"tags":[{"name":"html","slug":"html","permalink":"https://github.com/RShit/tags/html/"}],"author":"码农"},{"title":"Hello World","slug":"hello-world","date":"2019-03-07T02:39:24.133Z","updated":"2019-03-07T02:39:24.133Z","comments":true,"path":"2019/03/07/hello-world/","link":"","permalink":"https://github.com/RShit/2019/03/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}