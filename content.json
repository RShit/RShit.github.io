{"meta":{"title":"Hexo","subtitle":null,"description":"仰面朝天，知此身渺渺，沧海一粟","author":"liu666","url":"https://github.com/LBraveHeart","root":"/"},"pages":[{"title":"分类","date":"2019-05-29T02:18:26.000Z","updated":"2020-03-21T05:34:45.698Z","comments":false,"path":"categories/index.html","permalink":"https://github.com/LBraveHeart/categories/index.html","excerpt":"","text":"title: 分类date: 2020年3月21日13:30:37type: “categories”"},{"title":"标签","date":"2019-05-29T02:17:55.000Z","updated":"2020-03-21T05:34:55.998Z","comments":false,"path":"tags/index.html","permalink":"https://github.com/LBraveHeart/tags/index.html","excerpt":"","text":"title: 标签date: 2020年3月21日13:31:01type: “tags”"}],"posts":[{"title":"redis的使用及集群","slug":"dis的使用及集群","date":"2020-03-12T06:30:00.000Z","updated":"2020-03-21T05:31:37.698Z","comments":true,"path":"2020/03/12/dis的使用及集群/","link":"","permalink":"https://github.com/LBraveHeart/2020/03/12/dis的使用及集群/","excerpt":"","text":"redis数据结构 ：string:set key,value ,set key value ex time map所有的键值对的键和值的长度都小于等于64byte，哈希对象保存的键值对数量都小于512：ziplist，hashtable 对象 listquicklist 消息队列 setinset：如果元素类型都是整型，并且元素个数不小于512，hashtab，点赞，互相关注 zset元素数量小于128，所有member的长度小于64字节使用ziplist，否则升级为skiplist，热点排序 ，有一个score redis常用命令listlpush：左插入数据 lpushx：做插入数据， 前提条件是key存在并且key为列表 rpush：右插入 rpushx：右插入， 前提条件是key存在并且key为列表 rpop：右弹出 lpop：左弹出 lrange：弹出一个范围内的数据 blpop：左阻塞式的弹出 brpop：右阻塞式的弹出 set1、set：sadd添加，spop删除，smembers 查看所有元素，sinter交集，sunion合集，sdiff差集 mapzsetstringredis热点数据：1、客户端统计的方式 2、代理层：TwemProxy或 Codis 3、服务端统计：monitor监控，但是只能监控到一个节点 4、机器层面：抓包的形式 redis查看内存使用信息：info memory Redis主从复制master node 第一次执行全量复制，通过bgsave命令在本地生成一份RDB文件，将RDB快照文件发送给slave节点，slave node 会先清空自己的旧数据，然后从RDB文件中加载数据。 在生成rdb文件中，master node 如果接收到新的写命令怎么办？master会把所有的新的写命令缓存在内存中，在slave node 保存了RDB文件之后，再讲新的命令复制给slave node 主从复制的不足：1、当RDB文件过大时同步非常耗时 2、在一主多从情况下，当master node 挂了后。对外服务就不可用了，单点问题并没有解决。如果每次都手动把之前的服务器切换为主服务器，这就比较费力。 可用性保证之sentinelsentinel是一个监听，监听redis集群中的master和slave，如果master一定时间内没有给sentinel回复消息，则将master标记为下线，然后把某一个slave标记为master，应用每一次都从这个监控服务器拿到master的地址。 sentinel通过info命令来获取到redis集群中的节点的信息。 服务下线：当sentinel监听到master节点下线后，会进行故障转移 故障转移：故障转移的第一步就是在sentinel集群中选举出一个leader节点，然后让这个leader指定出一个master节点。 sentinel集群选举算法类似raft算法。raft算法：首先会生成一个150-300ms的时间，默认最小时间的为leader，如果时间一样则再次生成时间。 1、master客观下线会触发选举，而不是过了时间才会 2、leader并不会把自己成为leader的信息发送给其他sentinel节点。其他sentinel等待leader从slave选举出master后，检测新的master节点正常运行后，就会去掉客观下线的标识，从而不需要进入故障转移流程。 sentienl根据什么来指定master节点：1、断开连接时间：如果与哨兵连接断开时间过长，超过了某个阈值，就直接失去了选举权， 2、优先级：如果拥有了选举权，那就判断谁的优先级更高，数值越小优先级越高 3、复制数量：如果优先级也一样，就判断谁从master节点中复制的数据最多。 4、进程id：如果复制数量一样，就选择进程id最小的那个。 哨兵机制的不足：主从切换中会丢失数据，因为只有一个master，salve节点 的数据使用RDB文件复制的。 只能单点写，没有解决扩容的问题 如果数据量过大，我们就需要多个master-slave的group redis数据的分片客户端实现客户端根据key进行hash计算，来进行分片。 ShardedJedis 代理层将分片逻辑提取出来，运行一个独立的代理服务，客户端连接到这个代理服务，代理服务做请求转发。 Twemproxy，Codis 服务层Redis Cluster","categories":[{"name":"redis","slug":"redis","permalink":"https://github.com/LBraveHeart/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://github.com/LBraveHeart/tags/redis/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"Java面试题整理","slug":"va面试题整理","date":"2020-03-04T11:36:48.000Z","updated":"2020-03-04T11:40:29.465Z","comments":true,"path":"2020/03/04/va面试题整理/","link":"","permalink":"https://github.com/LBraveHeart/2020/03/04/va面试题整理/","excerpt":"","text":"JAVA 多个线程同时读写，读线程的数量量远远⼤大于写线程，你认为应该如何解决 并发的问题？你会选择加什么样的锁？ JAVA的AQS是否了了解，它是⼲干嘛的？ 除了了synchronized关键字之外，你是怎么来保障线程安全的？ 什么时候需要加volatile关键字？它能保证线程安全吗？ 线程池内的线程如果全部忙，提交⼀一个新的任务，会发⽣生什么？队列列全部 塞满了了之后，还是忙，再提交会发⽣生什什么？ Tomcat本身的参数你⼀一般会怎么调整？ synchronized关键字锁住的是什么东⻄西？在字节码中是怎么表示的？在内 存中的对象上表现为什么？ wait/notify/notifyAll⽅方法需不不需要被包含在synchronized块中？这是为什 么？ ExecutorService你⼀一般是怎么⽤用的？是每个service放⼀一个还是⼀一个项⽬目⾥里里⾯面放⼀一个？有什么好处？Spring 你有没有⽤用过Spring的AOP? 是⽤用来干嘛的? ⼤大概会怎么使⽤用？ 如果一个接口有2个不同的实现, 那么怎么来Autowire⼀一个指定的实现？ Spring的声明式事务 @Transaction注解⼀一般写在什么位置? 抛出了了异常会⾃自动回滚吗？有没有办法控制不不触发回滚? 如果想在某个Bean⽣生成并装配完毕后执⾏行行⾃自⼰己的逻辑，可以什么⽅方式实现？ SpringBoot没有放到web容器器⾥里里为什么能跑HTTP服务？ SpringBoot中如果你想使⽤用⾃自定义的配置⽂文件⽽而不不仅仅是application.properties，应该怎么弄弄？ SpringMVC中RequestMapping可以指定GET, POST方法么？怎么指定？ SpringMVC如果希望把输出的Object(例例如XXResult或者XXResponse)这种包装为JSON输出, 应该怎么处理理? 怎样拦截SpringMVC的异常，然后做⾃自定义的处理理，比如打⽇日志或者包装成JSONMySQL 如果有很多数据插⼊入MYSQL 你会选择什么⽅方式? 如果查询很慢，你会想到的第⼀一个⽅方式是什么？索引是⼲干嘛的? 如果建了了⼀一个单列列索引，查询的时候查出2列列，会⽤用到这个单列列索引吗？ 如果建了了⼀一个包含多个列列的索引，查询的时候只⽤用了了第⼀一列列，能不不能⽤用上这个索引？查三列列呢？ 接上题，如果where条件后⾯面带有⼀一个 i + 5 &lt; 100 会使⽤用到这个索引吗？ 怎么看是否⽤用到了了某个索引？ like %aaa%会使⽤用索引吗? like aaa%呢? drop、truncate、delete的区别？ 平时你们是怎么监控数据库的? 慢SQL是怎么排查的？ 你们数据库是否⽀支持emoji表情，如果不不⽀支持，如何操作? 你们的数据库单表数据量量是多少？⼀一般多⼤大的时候开始出现查询性能急剧下降？ 查询死掉了了，想要找出执⾏行行的查询进程⽤用什什么命令？找出来之后⼀一般你 会⼲干嘛？ 读写分离是怎么做的？你认为中间件会怎么来操作？这样操作跟事务有 什什么关系？ 分库分表有没有做过？线上的迁移过程是怎么样的？如何确定数据是正确的？JVM 你知道哪些或者你们线上使⽤用什什么GC策略略? 它有什什么优势，适⽤用于什什么场景？ JAVA类加载器器包括⼏几种？它们之间的⽗父⼦子关系是怎么样的？双亲委派机制是什什么意思？有什什么好处？ 如何⾃自定义⼀一个类加载器器？你使⽤用过哪些或者你在什什么场景下需要⼀一个⾃自定义的类加载器器吗？ 堆内存设置的参数是什什么？ Perm Space中保存什什么数据? 会引起OutOfMemory吗？ 做gc时，⼀一个对象在内存各个Space中被移动的顺序是什什么？ 你有没有遇到过OutOfMemory问题？你是怎么来处理理这个问题的？处理理过程中有哪些收获？ 1.8之后Perm Space有哪些变动? MetaSpace⼤大⼩小默认是⽆无限的么? 还是你们会通过什什么⽅方式来指定⼤大⼩小? Jstack是⼲干什什么的? Jstat呢? 如果线上程序周期性地出现卡顿，你怀疑可能是gc导致的，你会怎么来排查这个问题？线程⽇日志⼀一般你会看其中的什什么 部分？ StackOverFlow异常有没有遇到过？⼀一般你猜测会在什什么情况下被触发？如何指定⼀一个线程的堆栈⼤大⼩小？⼀一般你们写多少？Linux命令 ⽇日志特别⼤大只想看最后100⾏行行怎么弄弄? 如果想⼀一直看⽇日志的持续输出，⽤用什什么命令? 如果⽇日志⼀一边输出，⼀一边想实时看到有没有某个关键字应该怎么弄弄？ grep如果忽略略⼤大⼩小写应该怎么弄弄? 正则表达式呢？ vim往下⼀一⾏行行是什什么键？往下30⾏行行呢? 跳到⽂文件末尾⼀一⾏行行是什什么? 跳回来是什什么? 向后搜索是什什么? 如果有个⽂文本⽂文件，按空格作为列列的分隔符，如果想统计第三列列⾥里里⾯面的每个单词的出现次数应该怎么弄弄？ 如果把上⾯面的出现次数排个序应该怎么弄弄? 想按照数字本身的顺序⽽而不不是字符串串的顺序排列列怎么弄弄？ Linux环境变量量是以什什么作为分隔符的？环境变量量通过什什么命令设置？ 给某个⽂文件权设置限⽐比如设置为644 是⽤用什什么命令？这个6是什什么意思？ Linux下⾯面如果想看某个进程的资源占⽤用情况是怎么看的？系统load⼤大概 指的什什么意思？你们线上系统load⼀一般多少？如果⼀一个4核机器器，你认为多少load是⽐比较正常的？top命令⾥里里⾯面按⼀一下1会发⽣生什什么? top命令⾥里里⾯面，有时候所有进程的CPU使⽤用率加起来超过100%是怎么回 事？ 还有哪些查看系统性能或者供你发现问题的命令？你⼀一般是看哪个参数？ 想看某个进程打开了了哪些⽹网络连接是什什么命令？⾥里里⾯面连接的状态你⽐比较关⼼心哪⼏几种？– 偏题 有没有做过Linux系统参数⽅方⾯面的优化，⼤大概优化过什什么？ 系统参数⾥里里⾯面有个叫做backlog的可以⽤用来⼲干什什么？ 查看⽹网络连接发现好多TIME_WAIT 可能是什什么原因？对你的应⽤用会有什什么影响？你会选择什什么样的⽅方式来减少这些TIME_WAIT 可否介绍⼀一下TCP三次握⼿手的过程，如果现在有个⽹网络程序，你⽤用第三⽅方 的library来发送数据，你怀疑这个library发送的数据有问题，那么怎么来验 证？tcpdump导出的⽂文件你⼀一般是怎么分析的？ KeepAlive是⽤用来⼲干什什么的？这样的好处是什什么？Redis– 开发 缓存穿透可以介绍⼀一下么？你认为应该如何解决这个问题 你是怎么触发缓存更更新的？(⽐比如设置超时时间(被动⽅方式), ⽐比如更更新的时候主动update)？如果是被动的⽅方式如何控制多个⼊入⼝口同时触发某个缓存更更新？ 你们⽤用Redis来做什什么？为什什么不不⽤用其他的KV存储例例如Memcached,Cassandra等? 你们⽤用什什么Redis客户端? Redis⾼高性能的原因⼤大概可以讲⼀一些? 你熟悉哪些Redis的数据结构? zset是⼲干什什么的? 和set有什什么区别? Redis的hash, 存储和获取的具体命令叫什什么名字? LPOP和BLPOP的区别? Redis的有⼀一些包含SCAN关键字的命令是⼲干嘛的? SCAN返回的数据量量是固定的吗? Redis中的Lua有没有使⽤用过? 可以⽤用来做什什么? 为什什么可以这么⽤用? Redis的Pipeline是⽤用来⼲干什什么的?– 运维 Redis持久化⼤大概有⼏几种⽅方式? aof和rdb的区别是什什么? AOF有什什么优缺点吗? Redis Replication的⼤大致流程是什什么? bgsave这个命令的执⾏行行过程?– 偏题 如果有很多 KV数据要存储到Redis, 但是内存不不⾜足, 通过什什么⽅方式可以缩减内存? 为什什么这样可以缩⼩小内存? Redis中List, HashTable都⽤用到了了ZipList, 为什什么会选择它? 监控、稳定性 业务⽇日志是通过什什么⽅方式来收集的？ 线上机器器如何监控？采⽤用什什么开源产品或者⾃自研的产品？它是分钟级的还 是秒级的？ 如果让你来想办法收集⼀一个JAVA后端应⽤用的性能数据，你会在意哪些⽅方⾯面? 你会选择什什么样的⼯工具、思路路来收集? ⼀一般你调⽤用第三⽅方的时候会不不会监控调⽤用情况？","categories":[],"tags":[],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"线程池的基本使用","slug":"池的基本使用","date":"2020-03-04T09:39:53.000Z","updated":"2020-03-04T09:41:58.431Z","comments":true,"path":"2020/03/04/池的基本使用/","link":"","permalink":"https://github.com/LBraveHeart/2020/03/04/池的基本使用/","excerpt":"","text":"线程池的基本使用线程池的参数：1234567public ThreadPoolExecutor(int corePoolSize,// 核心线程数 int maximumPoolSize,// 最大线程数 long keepAliveTime,// 超过核心线程数的其他线程存活时间 TimeUnit unit,// 超过核心线程数的其他线程存活时间单位 BlockingQueue&lt;Runnable&gt; workQueue,// 阻塞队列 ThreadFactory threadFactory,// 线程创建工厂 RejectedExecutionHandler handler) // 拒绝策略 阻塞队列： 类名 说明 ArrayBlockingQueue 初始化是设置queue的大小 LinkedBlockingQueue 链表实现的有界阻塞队列, 此队列的默认和最大长度为Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序 SynchronousQueue 不存储元素的阻塞队列, 每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素。 PriorityBlockingQueue 支持优先级排序的无界阻塞队列, 默认情况下元素采取自然顺序升序排列。也可以自定义类实现 compareTo()方法来指定元素排序规则，或者初始化 PriorityBlockingQueue 时，指定构造参数 Comparator 来对元素进行排序。 DelayQueue 优先级队列实现的无界阻塞队列 LinkedTransferQueue 链表实现的无界阻塞队列 LinkedBlockingDeque 链表实现的双向阻塞队列 阻塞队列的操作：增加： API 说明 add 往Queue里添加数据，如果队列满了，抛出异常 offer 往Queue里添加数据，添加成功return true，添加失败return false enqueue(不能直接使用) 添加数据的具体操作，添加完成会signal()唤醒阻塞点线程 put 添加数据，阻塞式添加。 取出： API 说明 take 阻塞式取值 dequeue(不可直接使用) 取值核心逻辑 poll 非阻塞时取值 删除：remove删除数据。","categories":[],"tags":[],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"Spring 的事务传播性","slug":"ring-的事务传播性","date":"2020-03-04T07:45:24.000Z","updated":"2020-03-04T07:47:26.388Z","comments":true,"path":"2020/03/04/ring-的事务传播性/","link":"","permalink":"https://github.com/LBraveHeart/2020/03/04/ring-的事务传播性/","excerpt":"","text":"spring 的事务传播性 常量名称 常量解释 PROPAGATION_REQUIRED spring中的默认事务传播机制。支持当前事务，如果当前没有事务，就新建一个事务。 PROPAGATION_REQUIRES_NEW 新建事务，如果当前存在事务，则将当前事务挂起。新建的事务和被挂起的事务没有关联，是两个独立的事务，外层事务失败回滚后，不会影响到内层的事务。内层事务失败抛出异常后，外层事务捕获，也可以不处理回滚操作。 PROPAGITION_SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式运行 PROPAGITION_MANDATORY 支持当前事务，如果当前没有事务，则抛出异常。 PROPAGITION_NOT_SUPPORTED 以非事务方式运行，如果当前存在事务，则将当前事务挂起 PROPAGITION_NEVER 以非事务方式运行，如果当前存在事务，则抛出异常。 PROPAGITION_NESTED 如果一个活动事务存在，则运行在一个嵌套事务中。如果没有活动事务，则按REQUIRED运行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事物造成影响。他只对DataSourceTransationManager事务管理器起效。 REQUIRED 和 REQUIRES_NEW : 两个方法必须在不同的类中才会生效，才会创建新的事务。否则只会创建一个。","categories":[],"tags":[],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"乐观锁和悲观锁","slug":"浓缩和悲观锁","date":"2020-03-04T07:42:29.000Z","updated":"2020-03-04T07:44:42.316Z","comments":true,"path":"2020/03/04/浓缩和悲观锁/","link":"","permalink":"https://github.com/LBraveHeart/2020/03/04/浓缩和悲观锁/","excerpt":"","text":"乐观锁认为同一时间访问共享资源的线程不会冲突，所以采用共享资源的状态对资源进行修改。CAS操作也是乐观锁的体现。适合读多写少的操作。效率较高。 乐观锁的实现方式： 1、使用version方式，版本号控制对数据的操作 2、JDK的CAS操作就是乐观锁的一种实现。但是CAS可能会出现“ABA”的问题。 “ABA”问题：CAS操作表示compareAndSet,提供了三个参数，旧值V，预期值E，更新值U，当V和E相等时，才会对数据进行操作。但是操作时可能出现了其他线程对数据操作的情况：A --&gt; B --&gt;A，其他线程将数据改为B后又改回成A。所以前面的线程会对数据操作成功。类似于数据库的脏读问题 。 如何解决“ABA”问题采用version版本号控制，操作一次版本号version增加1，后续操作时带上参数version。版本号一直才会对数据操作。 悲观锁认为同一时间一定会有多个线程访问同一静态资源，所以采用对共享资源加锁的方式保证数据的安全性，如数据库操作的for update操作。","categories":[],"tags":[],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"java中的类加载顺序","slug":"ava中的类加载顺序","date":"2020-03-01T04:06:08.000Z","updated":"2020-03-01T04:06:22.240Z","comments":true,"path":"2020/03/01/ava中的类加载顺序/","link":"","permalink":"https://github.com/LBraveHeart/2020/03/01/ava中的类加载顺序/","excerpt":"","text":"1234567891011121314151617public class SingletonDemo &#123; private static SingletonDemo singletonDemo = new SingletonDemo(); private static int count1; private static int count2 = 0; public SingletonDemo() &#123; count1++; count2++; System.out.println(\"count1:\" + count1);// 1 System.out.println(\"count2:\" + count2);// 2 &#125; public static void main(String[] args) &#123; System.out.println(\"count1:\" + count1);// 3 System.out.println(\"count2:\" + count2);// 4 &#125;&#125; 分析： 类的加载过程为：转载 – 链接 – 初始化 装载：根据类全路径进行加载 链接包含三个步骤：验证 - 准备 - 解析。 验证： 文件格式验证 元数据验证 字节码验证 符号引用验证 准备：为类的静态变量分配内存，并将其初始化为默认值。 解析：把类中的符号引用转换为直接引用 初始化阶段会初始化类中的： 静态成员变量singletonDemo，初始化时，count1和count2默认为0，初始化后count1和count2都是1，所以1和2位置输出均为1。 静态变量count1和count2，初始化前count1和count2都是1，初始化后count2被赋值为0。所以3和4的位置输出1,0","categories":[],"tags":[],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"交换两个integer的值","slug":"两个integer的值","date":"2020-03-01T03:21:13.000Z","updated":"2020-03-01T03:23:43.625Z","comments":true,"path":"2020/03/01/两个integer的值/","link":"","permalink":"https://github.com/LBraveHeart/2020/03/01/两个integer的值/","excerpt":"","text":"核心思想：通过反射设置integer的value属性。123456789101112131415161718192021222324public class Swap &#123; public static void main(String[] args) &#123; Integer i1 = 1; Integer i2 = 2; System.out.println(\"before:\" + \"i1:\" + i1+ \"- i2:\" + i2) ; swap(i1,i2); System.out.println(\"after:\" + \"i1:\" + i1+ \"- i2:\" + i2) ; System.out.println(new Integer(1) == i1); &#125; public static void swap(Integer i1,Integer i2) &#123; try &#123; Field field = Integer.class.getDeclaredField(\"value\"); field.setAccessible(true); int tmp = i1.intValue(); field.setInt(i1,i2); field.setInt(i2,tmp); &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[],"tags":[],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"java对象的强引用、软引用、弱引用、虚引用","slug":"ava对象的强引用、软引用、弱引用、虚引用","date":"2020-03-01T03:15:50.000Z","updated":"2020-03-01T03:15:59.599Z","comments":true,"path":"2020/03/01/ava对象的强引用、软引用、弱引用、虚引用/","link":"","permalink":"https://github.com/LBraveHeart/2020/03/01/ava对象的强引用、软引用、弱引用、虚引用/","excerpt":"","text":"强引用强引用在对象不被使用时，并且也发生了gc，但是也不会被回收，直到发生oom 12345678910/** * 强引用 */public static void strongRef() &#123; Object strongObj = obj; obj = null; System.gc(); System.out.println(strongObj);&#125;java.lang.Object@677327b6 软引用软引用在即将发生OOM时，会对没有使用的对象回收。 1234567891011/** * 软引用 */public static void softRef() &#123; Object softObj = new Object(); SoftReference softReference = new SoftReference(softObj); softObj = null; System.gc(); System.out.println(softReference.get());&#125;java.lang.Object@677327b6 弱引用发生GC时，就会对没有使用的对象进行回收。 1234567891011121314151617/** * 弱引用 */public static void weakRef() &#123; Object weakObj = new Object(); WeakReference weakReference = new WeakReference(weakObj); weakObj = null; try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.gc();; System.out.println(weakReference.get());&#125;java.lang.Object@677327b6null 虚引用虚引用不管在使用时还是未使用时直接取值都会是null，但是对象未被使用时(=null)会将对象放入到queue中。如果对象还在使用，则不放入。 12345678910111213141516171819/** * 虚引用 */public static void phantomRef() &#123; Object o = new Object(); ReferenceQueue queue = new ReferenceQueue(); PhantomReference phantomReference = new PhantomReference(o, queue); o = null; System.gc(); System.out.println(phantomReference.get()); try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(queue.poll());&#125;nulljava.lang.ref.PhantomReference@677327b6","categories":[],"tags":[],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"数组int[] 转换为Integer[]","slug":"int-转换为Integer","date":"2020-03-01T02:18:02.000Z","updated":"2020-03-01T02:20:53.773Z","comments":true,"path":"2020/03/01/int-转换为Integer/","link":"","permalink":"https://github.com/LBraveHeart/2020/03/01/int-转换为Integer/","excerpt":"","text":"123int [] a = new int[]&#123;6,3,7,9&#125;;Integer[] integers = Arrays.stream(a).boxed().toArray(Integer[]::new);System.out.println(Arrays.toString(integers));","categories":[],"tags":[],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"vps","slug":"ps","date":"2020-02-27T10:18:47.000Z","updated":"2020-03-01T02:24:08.342Z","comments":true,"path":"2020/02/27/ps/","link":"","permalink":"https://github.com/LBraveHeart/2020/02/27/ps/","excerpt":"","text":"下载get-pip.py1curl \"https://bootstrap.pypa.io/get-pip.py\" -o \"get-pip.py\" 执行get-pip.py1python get-pip.py 安装pip1pip install --upgrade pip 安装shadowsocks1pip install shadowsocks 配置文件12345678vi /etc/shadowsocks.json&#123; \"server\": \"0.0.0.0\", \"server_port\": 2018, \"password\": \"12345678\", \"method\": \"aes-256-cfb\"&#125; 启动shadowsocks1ssserver -c /etc/shadowsocks.json -d start 关闭防火墙1systemctl stop firewalld.service 关闭shadowsocks1ssserver -c /etc/shadowsocks.json -d stop","categories":[],"tags":[],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"About Me","slug":"out-Me","date":"2020-02-25T13:22:57.000Z","updated":"2020-02-25T13:52:34.766Z","comments":true,"path":"2020/02/25/out-Me/","link":"","permalink":"https://github.com/LBraveHeart/2020/02/25/out-Me/","excerpt":"","text":"A Java Coder, live in BeiJing, China.GitHub:BraveHeartQQ:318635503","categories":[],"tags":[],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"idea快捷键使用","slug":"dea快捷键使用","date":"2019-12-31T01:10:09.000Z","updated":"2019-12-31T01:33:38.513Z","comments":true,"path":"2019/12/31/dea快捷键使用/","link":"","permalink":"https://github.com/LBraveHeart/2019/12/31/dea快捷键使用/","excerpt":"","text":"自动代码常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码 。 例如：要输入for(User user : users)只需输入user.for+Tab; 再比如：要输入Date birthday = user.getBirthday()只需输入user.getBirthday().var+Tab即可。 代码标签输入完成后，按Tab，生成代码。 Ctrl+Alt+O 优化导入的类和包 Alt+Insert 生成代码(如get,set方法,构造函数等) 或者右键（Generate） fori/sout/psvm + Tab Ctrl+Alt+T 生成try catch 或者 Alt+enter CTRL+ALT+T 把选中的代码放在 TRY{} IF{} ELSE{} 里 Ctrl + O 重写方法 Ctrl + I 实现方法 Ctr+shift+U 大小写转化 ALT+回车 导入包,自动修正 ALT+/ 代码提示 CTRL+J 自动代码 Ctrl+Shift+J，整合两行为一行 CTRL+空格 代码提示 CTRL+SHIFT+SPACE 自动补全代码 CTRL+ALT+L 格式化代码 CTRL+ALT+I 自动缩进 CTRL+ALT+O 优化导入的类和包 ALT+INSERT 生成代码(如GET,SET方法,构造函数等) CTRL+E 最近更改的代码 CTRL+ALT+SPACE 类名或接口名提示 CTRL+P 方法参数提示 CTRL+Q，可以看到当前方法的声明 Shift+F6 重构-重命名 (包、类、方法、变量、甚至注释等) Ctrl+Alt+V 提取变量 查询快捷键Ctrl＋Shift＋Backspace可以跳转到上次编辑的地CTRL+ALT+ left/right 前后导航编辑过的地方ALT+7 靠左窗口显示当前文件的结构Ctrl+F12 浮动显示当前文件的结构ALT+F7 找到你的函数或者变量或者类的所有引用到的地方CTRL+ALT+F7 找到你的函数或者变量或者类的所有引用到的地方Ctrl+Shift+Alt+N 查找类中的方法或变量双击SHIFT 在项目的所有目录查找文件Ctrl+N 查找类Ctrl+Shift+N 查找文件CTRL+G 定位行CTRL+F 在当前窗口查找文本CTRL+SHIFT+F 在指定窗口查找文本CTRL+R 在 当前窗口替换文本CTRL+SHIFT+R 在指定窗口替换文本ALT+SHIFT+C 查找修改的文件CTRL+E 最近打开的文件F3 向下查找关键字出现位置SHIFT+F3 向上一个关键字出现位置选中文本，按Alt+F3 ，高亮相同文本，F3逐个往下查找相同文本F4 查找变量来源CTRL+SHIFT+O 弹出显示查找内容Ctrl+W 选中代码，连续按会有其他效果F2 或Shift+F2 高亮错误或警告快速定位Ctrl+Up/Down 光标跳转到第一行或最后一行下Ctrl+B 快速打开光标处的类或方法CTRL+ALT+B 找所有的子类CTRL+SHIFT+B 找变量的类Ctrl+Shift+上下键 上下移动代码Ctrl+Alt+ left/right 返回至上次浏览的位置Ctrl+X 删除行Ctrl+D 复制行Ctrl+/ 或 Ctrl+Shift+/ 注释（// 或者/…/ ）Ctrl+H 显示类结构图Ctrl+Q 显示注释文档Alt+F1 查找代码所在位置Alt+1 快速打开或隐藏工程面板Alt+ left/right 切换代码视图ALT+ ↑/↓ 在方法间快速移动定位CTRL+ALT+ left/right 前后导航编辑过的地方Ctrl＋Shift＋Backspace可以跳转到上次编辑的地Alt+6 查找TODO 其他快捷键SHIFT+ENTER 另起一行CTRL+Z 倒退(撤销)CTRL+SHIFT+Z 向前(取消撤销)CTRL+ALT+F12 资源管理器打开文件夹ALT+F1 查找文件所在目录位置SHIFT+ALT+INSERT 竖编辑模式CTRL+F4 关闭当前窗口Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单） svn快捷键ctrl+k 提交代码到SVNctrl+t 更新代码 调试快捷键其实常用的 就是F8 F7 F9 最值得一提的就是Drop Frame 可以让运行过的代码从头再来。 alt+F8 debug时选中查看值Alt+Shift+F9，选择 DebugAlt+Shift+F10，选择 RunCtrl+Shift+F9，编译Ctrl+Shift+F8，查看断点F7，步入Shift+F7，智能步入Alt+Shift+F7，强制步入F8，步过Shift+F8，步出Alt+Shift+F8，强制步过Alt+F9，运行至光标处Ctrl+Alt+F9，强制运行至光标处F9，恢复程序Alt+F10，定位到断点 重构Ctrl+Alt+Shift+T，弹出重构菜单Shift+F6，重命名F6，移动F5，复制Alt+Delete，安全删除Ctrl+Alt+N，内联 十大Intellij IDEA快捷键Intellij IDEA中有很多快捷键让人爱不释手，stackoverflow上也有一些有趣的讨论。每个人都有自己的最爱，想排出个理想的榜单还真是困难。 以前也整理过Intellij的快捷键，这次就按照我日常开发时的使用频率，简单分类列一下我最喜欢的十大快捷-神-键吧。 1 智能提示:Intellij首当其冲的当然就是Intelligence智能！基本的代码提示用Ctrl+Space，还有更智能地按类型信息提示Ctrl+Shift+Space，但因为Intellij总是随着我们敲击而自动提示，所以很多时候都不会手动敲这两个快捷键(除非提示框消失了)。 用F2/ Shift+F2移动到有错误的代码，Alt+Enter快速修复(即Eclipse中的Quick Fix功能)。当智能提示为我们自动补全方法名时，我们通常要自己补上行尾的反括号和分号，当括号嵌套很多层时会很麻烦，这时我们只需敲Ctrl+Shift+Enter就能自动补全末尾的字符。而且不只是括号，例如敲完if/for时也可以自动补上{}花括号。 最后要说一点，Intellij能够智能感知Spring、Hibernate等主流框架的配置文件和类，以静制动，在看似“静态”的外表下，智能地扫描理解你的项目是如何构造和配置的。 2 重构:Intellij重构是另一完爆Eclipse的功能，其智能程度令人瞠目结舌，比如提取变量时自动检查到所有匹配同时提取成一个变量等。尤其看过《重构-改善既有代码设计》之后，有了Intellij的配合简直是令人大呼过瘾！也正是强大的智能和重构功能，使Intellij下的TDD开发非常顺畅。 切入正题，先说一个无敌的重构功能大汇总快捷键Ctrl+Shift+Alt+T，叫做Refactor This。按法有点复杂，但也符合Intellij的风格，很多快捷键都要双手完成，而不像Eclipse不少最有用的快捷键可以潇洒地单手完成(不知道算不算Eclipse的一大优点)，但各位用过Emacs的话就会觉得也没什么了(非Emacs黑)。 此外，还有些最常用的重构技巧，因为太常用了，若每次都在Refactor This菜单里选的话效率有些低。比如Shift+F6直接就是改名，Ctrl+Alt+V则是提取变量。关注Java技术栈微信公众号，在后台回复关键字：IDEA，可以获取一份栈长整理的 IDEA 最新技术干货。 3 代码生成:这一点类似Eclipse，虽不是独到之处，但因为日常使用频率极高，所以还是罗列在榜单前面。常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码，用Ctrl+J可以查看所有模板。 后面“辅助”一节中将会讲到Alt+Insert，在编辑窗口中点击可以生成构造函数、toString、getter/setter、重写父类方法等。这两个技巧实在太常用了，几乎每天都要生成一堆main、System.out和getter/setter。 另外，Intellij IDEA 13中加入了后缀自动补全功能(Postfix Completion)，比模板生成更加灵活和强大。例如要输入for(User user : users)只需输入user.for+Tab。再比如，要输入Date birthday = user.getBirthday();只需输入user.getBirthday().var+Tab即可。 4 编辑：编辑中不得不说的一大神键就是能够自动按语法选中代码的Ctrl+W以及反向的Ctrl+Shift+W了。此外，Ctrl+Left/Right移动光标到前/后单词，Ctrl+[/]移动到前/后代码块，这些类Vim风格的光标移动也是一大亮点。以上Ctrl+Left/Right/[]加上Shift的话就能选中跳跃范围内的代码。Alt+Forward/Backward移动到前/后方法。还有些非常普通的像Ctrl+Y删除行、Ctrl+D复制行、Ctrl+折叠代码就不多说了。 关于光标移动再多扩展一点，除了Intellij本身已提供的功能外，我们还可以安装ideaVim或者emacsIDEAs享受到Vim的快速移动和Emacs的AceJump功能(超爽！)。 另外，Intellij的书签功能也是不错的，用Ctrl+Shift+Num定义1-10书签(再次按这组快捷键则是删除书签)，然后通过Ctrl+Num跳转。这避免了多次使用前/下一编辑位置Ctrl+Left/Right来回跳转的麻烦，而且此快捷键默认与Windows热键冲突(默认多了Alt，与Windows改变显示器显示方向冲突，一不小心显示器就变成倒着显式的了，冏啊)。 5 查找打开：类似Eclipse，Intellij的Ctrl+N/Ctrl+Shift+N可以打开类或资源，但Intellij更加智能一些，我们输入的任何字符都将看作模糊匹配，省却了Eclipse中还有输入*的麻烦。最新版本的IDEA还加入了Search Everywhere功能，只需按Shift+Shift即可在一个弹出框中搜索任何东西，包括类、资源、配置项、方法等等。 类的继承关系则可用Ctrl+H打开类层次窗口，在继承层次上跳转则用Ctrl+B/Ctrl+Alt+B分别对应父类或父方法定义和子类或子方法实现，查看当前类的所有方法用Ctrl+F12。 要找类或方法的使用也很简单，Alt+F7。要查找文本的出现位置就用Ctrl+F/Ctrl+Shift+F在当前窗口或全工程中查找，再配合F3/Shift+F3前后移动到下一匹配处。 Intellij更加智能的又一佐证是在任意菜单或显示窗口，都可以直接输入你要找的单词，Intellij就会自动为你过滤。 关注Java技术栈微信公众号，在后台回复关键字：IDEA，可以获取一份栈长整理的 IDEA 最新技术干货。 6 其他辅助：以上这些神键配上一些辅助快捷键，即可让你的双手90%以上的时间摆脱鼠标，专注于键盘仿佛在进行钢琴表演。这些不起眼却是至关重要的最后一块拼图有： Ø 命令：Ctrl+Shift+A可以查找所有Intellij的命令，并且每个命令后面还有其快捷键。所以它不仅是一大神键，也是查找学习快捷键的工具。 Ø 新建：Alt+Insert可以新建类、方法等任何东西。 Ø 格式化代码：格式化import列表Ctrl+Alt+O，格式化代码Ctrl+Alt+L。 Ø 切换窗口：Alt+Num，常用的有1-项目结构，3-搜索结果，4/5-运行调试。Ctrl+Tab切换标签页，Ctrl+E/Ctrl+Shift+E打开最近打开过的或编辑过的文件。 Ø 单元测试：Ctrl+Alt+T创建单元测试用例。 Ø 运行：Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止。 Ø 调试：F7/F8/F9分别对应Step into，Step over，Continue。 此外还有些我自定义的，例如水平分屏Ctrl+|等，和一些神奇的小功能Ctrl+Shift+V粘贴很早以前拷贝过的，Alt+Shift+Insert进入到列模式进行按列选中。 Ø Top #10切来切去：Ctrl+Tab Ø Top #9选你所想：Ctrl+W Ø Top #8代码生成：Template/Postfix +Tab Ø Top #7发号施令：Ctrl+Shift+A Ø Top #6无处藏身：Shift+Shift Ø Top #5自动完成：Ctrl+Shift+Enter Ø Top #4创造万物：Alt+Insert 太难割舍，前三名并列吧！ Ø Top #1智能补全：Ctrl+Shift+Space Ø Top #1自我修复：Alt+Enter Ø Top #1重构一切：Ctrl+Shift+Alt+T CTRL+ALT+ left/right 前后导航编辑过的地方Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方","categories":[],"tags":[],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"centos7 配置jdk","slug":"ntos7-配置jdk","date":"2019-12-30T02:17:41.000Z","updated":"2019-12-30T02:27:52.728Z","comments":true,"path":"2019/12/30/ntos7-配置jdk/","link":"","permalink":"https://github.com/LBraveHeart/2019/12/30/ntos7-配置jdk/","excerpt":"","text":"下载jdk压缩包链接：https://pan.baidu.com/s/1As4LjS8FrunJhkP16B9Xdg提取码：79es复制这段内容后打开百度网盘手机App，操作更方便哦 将jdk压缩包上传至centos7中1rz 解压jdk压缩包1tar -zxvf jdk-8u231-linux-x64.tar.gz 配置环境变量1vim /etc/profile 将下面的代码复制到最后：将第一行中路径修改为解压后的jdk目录位置 12345export JAVA_HOME=/usr/java/jdk/jdk1.8.0_231export PATH=$JAVA_HOME/bin:$PATHexportCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar","categories":[],"tags":[],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"idea创建maven很慢时，设置属性","slug":"ea创建maven很慢时，设置属性","date":"2019-12-26T02:46:32.000Z","updated":"2019-12-26T02:48:47.302Z","comments":true,"path":"2019/12/26/ea创建maven很慢时，设置属性/","link":"","permalink":"https://github.com/LBraveHeart/2019/12/26/ea创建maven很慢时，设置属性/","excerpt":"","text":"1-DarchetypeCatalog=internal","categories":[],"tags":[],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"centos 7安装redis","slug":"entos-7安装redis","date":"2019-12-18T02:06:59.000Z","updated":"2019-12-30T10:03:08.706Z","comments":true,"path":"2019/12/18/entos-7安装redis/","link":"","permalink":"https://github.com/LBraveHeart/2019/12/18/entos-7安装redis/","excerpt":"","text":"普通安装下载安装包1wget http://download.redis.io/releases/redis-5.0.7.tar.gz 解压文件1tar -zxvf redis-5.0.7 编译123cd redis-5.0.7make 编译可能出现的问题12345make[1]: [persist-settings] Error 2 (ignored) CC adlist.o出现该问题时：错误是因为一些依赖包未安装yum -y install gcc gcc-c++ libstdc++-devel 解决 1234zmalloc.h:50:31: fatal error: jemalloc/jemalloc.h: No such file or directory #include &lt;jemalloc/jemalloc.h&gt; 出现该问题时：make MALLOC=libc 解决 redis设置登录密码1在redis.conf 配置文件添加`requirepass`属性保存 redis设置后台启动1在redis.conf 配置文件设置`daemonize yes`属性保存 使用docker-compose安装redis创建docker-compose.yml文件12345678910version: '2'services: redis: image: redis:5.0.5 container_name: redis command: redis-server --requirepass 123456 ports: - \"16379:6379\" volumes: - ./data:/data 启动docker-compose1docker-compose up -d 使用redis命令行客户端123456先查看redis的容器iddocker ps 进入redis容器docker exec -it 1742ad5e9da8 bash启动redis客户端redis-cli -h 127.0.0.1 -p 6379 -a 123456","categories":[],"tags":[],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"linux统计文件夹信息","slug":"inux统计文件夹信息","date":"2019-11-21T07:40:12.000Z","updated":"2019-11-21T07:43:43.070Z","comments":true,"path":"2019/11/21/inux统计文件夹信息/","link":"","permalink":"https://github.com/LBraveHeart/2019/11/21/inux统计文件夹信息/","excerpt":"","text":"查看当前文件夹所有文件的个数(不包括文件夹)1ls -l |grep &quot;^-&quot;|wc -l 查看当前文件夹所有目录的个数1ls -l |grep &quot;^ｄ&quot;|wc -l 查看当前文件夹所有文件个数(包括子目录)1ls -lR|grep &quot;^-&quot;|wc -l 查看当前文件夹下所有目录的个数(包含子目录)1ls -lR|grep &quot;^d&quot;|wc -l","categories":[],"tags":[],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"centos7 mysql的安装及初始化配置","slug":"ntos7-mysql启动与停止","date":"2019-11-19T07:46:58.000Z","updated":"2019-12-30T10:18:47.085Z","comments":true,"path":"2019/11/19/ntos7-mysql启动与停止/","link":"","permalink":"https://github.com/LBraveHeart/2019/11/19/ntos7-mysql启动与停止/","excerpt":"","text":"普通方法安装安装YUM Repo由于CentOS 的yum源中没有mysql，需要到mysql的官网下载yum repo配置文件。 1wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm 然后进行repo的安装：1rpm -ivh mysql57-community-release-el7-9.noarch.rpm 安装mysql1yum install mysql-server 启动mysql1service mysqld start 配置MySQL获取安装时的临时密码：1grep &apos;temporary password&apos; /var/log/mysqld.log 倘若没有 （1）删除原来安装过的mysql残留的数据 1rm -rf /var/lib/mysql （2）再启动mysql 1service mysqld start 登录1mysql -u root -p 登录成功后需要先修改密码：1ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;; 在设置密码时，但密码在简单时会出现ERROR 1819 (HY000): Your password does not satisfy the current policy requirements的错误设置参数：12set global validate_password_policy=0;set global validate_password_length=1; 这时再设置密码就不错报错了。 修改登录权限12GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos; WITH GRANT OPTION;FLUSH PRIVILEGES; 查看mysql运行状态1service mysqld status 停止mysql1service mysqld stop 使用docker-compsoe安装创建docker-compose.yml文件12345678910111213version: '2'services: db: image: 'mysql/mysql-server:5.7' restart: always container_name: mysql57 environment: MYSQL_USER: 用户名 MYSQL_PASSWORD: 密码 MYSQL_DATABASE: 初始创建的数据库 MYSQL_ROOT_PASSWORD: root用户密码 ports: - '3306:3306'//映射端口 启动docker-compsoe12启动docker-compose(后台模式，不打印日志)docker-compose up -d 进入容器创建用户进入docker中的mysql容器查看mysql容器的id1docker ps 进入docker容器命令行1docker exec -it mysql容器id bash 进入mysql命令行 1mysql -u root -p 可以使用docker配置文件中创建的用户也可以创建新用户 创建新用户:1create user &apos;admin001&apos;@&apos;%&apos; identified by &apos;123456&apos;; 删除用户：1DROP USER &apos;admin001&apos;@&apos;%&apos;; 给用户赋权限：12grant all privileges on *.* to &apos;admin001&apos;@&apos;%&apos; identified by &apos;123456&apos;;flush privileges;","categories":[],"tags":[],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"vagrant+virtualBox搭建centos7虚拟机","slug":"agrant-virtualBox搭建centos7虚拟机","date":"2019-11-18T08:28:36.000Z","updated":"2019-11-18T08:28:37.424Z","comments":true,"path":"2019/11/18/agrant-virtualBox搭建centos7虚拟机/","link":"","permalink":"https://github.com/LBraveHeart/2019/11/18/agrant-virtualBox搭建centos7虚拟机/","excerpt":"","text":"","categories":[],"tags":[],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"linux查看端口占用","slug":"inux查看端口占用","date":"2019-10-23T08:55:34.000Z","updated":"2019-10-23T08:55:34.707Z","comments":true,"path":"2019/10/23/inux查看端口占用/","link":"","permalink":"https://github.com/LBraveHeart/2019/10/23/inux查看端口占用/","excerpt":"","text":"1lsof -i:端口","categories":[],"tags":[],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"centos7关闭防火墙","slug":"ntos7关闭防火墙","date":"2019-10-22T10:05:36.000Z","updated":"2019-10-23T08:54:57.158Z","comments":true,"path":"2019/10/22/ntos7关闭防火墙/","link":"","permalink":"https://github.com/LBraveHeart/2019/10/22/ntos7关闭防火墙/","excerpt":"","text":"1sudo systemctl stop firewalld.service &amp;&amp; sudo systemctl disable firewalld.service","categories":[],"tags":[],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"判断一个数是否为NaN","slug":"一个数是否为NaN","date":"2019-10-10T08:30:19.000Z","updated":"2019-10-10T08:32:27.370Z","comments":true,"path":"2019/10/10/一个数是否为NaN/","link":"","permalink":"https://github.com/LBraveHeart/2019/10/10/一个数是否为NaN/","excerpt":"","text":"1Double.isNaN(d)","categories":[],"tags":[],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"js滚动到指定位置","slug":"滚动到指定位置","date":"2019-09-17T09:19:58.000Z","updated":"2019-09-17T09:22:08.549Z","comments":true,"path":"2019/09/17/滚动到指定位置/","link":"","permalink":"https://github.com/LBraveHeart/2019/09/17/滚动到指定位置/","excerpt":"","text":"1$(\".html\").animate(&#123;scrollTop:'0px'&#125;, 200);","categories":[],"tags":[],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"mysql去重语句","slug":"sql去除语句","date":"2019-07-30T07:41:27.000Z","updated":"2019-07-31T09:42:53.234Z","comments":true,"path":"2019/07/30/sql去除语句/","link":"","permalink":"https://github.com/LBraveHeart/2019/07/30/sql去除语句/","excerpt":"","text":"1SELECT DISTINCT(u.userId) FROM `user` u where u.status='1';","categories":[],"tags":[],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"idea去除重复代码检测","slug":"ea去除重复代码检测","date":"2019-07-26T09:36:00.000Z","updated":"2019-07-26T09:42:23.484Z","comments":true,"path":"2019/07/26/ea去除重复代码检测/","link":"","permalink":"https://github.com/LBraveHeart/2019/07/26/ea去除重复代码检测/","excerpt":"","text":"如图： 将红框部分去选勾选","categories":[{"name":"idea","slug":"idea","permalink":"https://github.com/LBraveHeart/categories/idea/"}],"tags":[{"name":"idea","slug":"idea","permalink":"https://github.com/LBraveHeart/tags/idea/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"excel导出poi处理及table转为excel","slug":"xcel导出poi处理及table转为excel","date":"2019-07-26T08:49:00.000Z","updated":"2019-07-26T09:28:14.039Z","comments":true,"path":"2019/07/26/xcel导出poi处理及table转为excel/","link":"","permalink":"https://github.com/LBraveHeart/2019/07/26/xcel导出poi处理及table转为excel/","excerpt":"","text":"poi导出使用poi导出大量数据时，可以使用 SXSSFWorkbook 使用方法： 导入poi包及poi-ooxml包 12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.17&lt;/version&gt; &lt;/dependency&gt; 具体代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.liuyy.excel;import org.apache.poi.ss.usermodel.Font;import org.apache.poi.xssf.streaming.SXSSFCell;import org.apache.poi.xssf.streaming.SXSSFRow;import org.apache.poi.xssf.streaming.SXSSFSheet;import org.apache.poi.xssf.streaming.SXSSFWorkbook;import java.io.FileOutputStream;import java.io.IOException;/** * @author liuyy * @className PoiExcelDemo * @description TODO * @date 2019/7/26 16:55 **/public class PoiExcelDemo &#123; public static void main(String[] args) &#123; exportExcel(\"数据导出.xls\"); &#125; public static void exportExcel(String fileName)&#123; SXSSFWorkbook workbook = new SXSSFWorkbook(); //输出Excel文件 FileOutputStream output = null; try &#123; //添加Worksheet（不添加sheet时生成的xls文件打开时会报错) String sheetName = \"数据导出\"; SXSSFSheet sheet = workbook.createSheet(sheetName); // 设置缺省列高 sheet.setDefaultRowHeightInPoints(20); // 设置缺省列宽 sheet.setDefaultColumnWidth(20); // 设置字体 Font fontStyle = workbook.createFont(); fontStyle.setFontName(\"宋体\"); fontStyle.setFontHeightInPoints((short) 20); // 创建XSSFRow对象 // 创建第一行-表头 SXSSFRow rowHead = sheet.createRow(0); for (int i = 0; i &lt; 8; i++) &#123; //创建XSSFCell对象 SXSSFCell cellHead = rowHead.createCell(i); //设置单元格的值 cellHead.setCellValue(i); &#125; // 创建具体数据 for (int i = 0; i &lt; 100; i++) &#123; // 第i+1行 SXSSFRow row = sheet.createRow(i + 1); row.createCell(0).setCellValue(\"第1列\"); row.createCell(1).setCellValue(\"第2列\"); row.createCell(2).setCellValue(\"第3列\"); row.createCell(3).setCellValue(\"第4列\"); row.createCell(4).setCellValue(\"第5列\"); row.createCell(5).setCellValue(\"第6列\"); &#125; output = new FileOutputStream(fileName); workbook.write(output); output.flush(); workbook.close(); output.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; workbook.close(); output.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 结果如果所示： table导出代码如下： 12345678910111213141516171819//获取表格var exportFileContent = document.getElementById(\"showTable\").outerHTML;//设置格式为Excel，表格内容通过btoa转化为base64，此方法只在文件较小时使用(小于1M)//exportFileContent = window.btoa(unescape(encodeURIComponent(exportFileContent)));//var link = \"data:\"+MIMEType+\";base64,\" + exportFileContent;//使用Blobvar blob = new Blob([exportFileContent], &#123;type: \"text/plain;charset=utf-8\"&#125;);//解决中文乱码问题blob = new Blob([String.fromCharCode(0xFEFF), blob], &#123;type: blob.type&#125;);//设置链接var link = window.URL.createObjectURL(blob);var a = document.createElement(\"a\"); //创建a标签a.download = filenName+\".xls\"; //设置被下载的超链接目标（文件名）a.href = link; //设置a标签的链接document.body.appendChild(a); //a标签添加到页面a.click(); //设置a标签触发单击事件document.body.removeChild(a); //移除a标签","categories":[{"name":"excel","slug":"excel","permalink":"https://github.com/LBraveHeart/categories/excel/"}],"tags":[{"name":"html","slug":"html","permalink":"https://github.com/LBraveHeart/tags/html/"},{"name":"java","slug":"java","permalink":"https://github.com/LBraveHeart/tags/java/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"Integer.MAX_VALUE 面试题","slug":"nteger-MAX-VALUE-面试题","date":"2019-07-18T08:02:00.000Z","updated":"2019-07-26T09:31:08.838Z","comments":true,"path":"2019/07/18/nteger-MAX-VALUE-面试题/","link":"","permalink":"https://github.com/LBraveHeart/2019/07/18/nteger-MAX-VALUE-面试题/","excerpt":"","text":"如下代码：1234567final int start = Integer.MAX_VALUE-100;final int end = Integer.MAX_VALUE;int count = 0;for (int i = start; i &lt;= end;i++) &#123; count++;&#125;System.out.println(count); 输出结果为？没有输出结果 分析Integer.MAX_VALUE用二进制表示1111 1111 1111 1111 1111 1111 1111 111 所以当i++一直到=end时，即i = Integer.MAX_VALUE时,此时计算的结果为100，但是当接着往下面执行时，i++即 i = Integer.MAX_VALUE+1，i此时二进制1111 1111 1111 1111 1111 1111 1111 111 + 1 的结果为-1000 0000 0000 0000 0000 0000 0000 0000，即i = -2147483648，符合 i &lt; end条件，所以循环接着往下执行，一直到=end，+1后又变为负数，周而复始，所以不会有结果输出。","categories":[{"name":"java","slug":"java","permalink":"https://github.com/LBraveHeart/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/LBraveHeart/tags/java/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"short/int 易错面试题","slug":"ort-int-出人意料代码","date":"2019-07-18T03:46:00.000Z","updated":"2019-07-26T09:31:16.197Z","comments":true,"path":"2019/07/18/ort-int-出人意料代码/","link":"","permalink":"https://github.com/LBraveHeart/2019/07/18/ort-int-出人意料代码/","excerpt":"","text":"123456789HashSet&lt;Short&gt; set = new HashSet&lt;&gt;();for (short i = 0; i &lt; 100; i++) &#123; // set.add set添加的类型为short set.add(i); // 通过计算得知 int i1 = i - 1,i-1返回的是一个int类型的值，所以remove时找不到需要remove的值 set.remove(i-1);&#125;// 从而size是100System.out.println(set.size());","categories":[{"name":"java","slug":"java","permalink":"https://github.com/LBraveHeart/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/LBraveHeart/tags/java/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"远程通讯协议-tcp/ip及nio的学习笔记","slug":"程通讯协议-tcp-ip及nio的学习笔记","date":"2019-07-17T09:39:00.000Z","updated":"2020-03-20T09:16:33.188Z","comments":true,"path":"2019/07/17/程通讯协议-tcp-ip及nio的学习笔记/","link":"","permalink":"https://github.com/LBraveHeart/2019/07/17/程通讯协议-tcp-ip及nio的学习笔记/","excerpt":"","text":"tcp 7层 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 4层网络模型： 其中应用层、表示层、会话层表示应用层，数据链路层、物理层表示网络接口层 ARP协议复杂的程序都需要分层，软件开发设计必须要做的 tcp负载均衡二层负载 -&gt; mac地址，vip(虚拟ip) 多个机器IP相同但是mac地址不同 三层负载 -&gt;ip 对外提供虚拟ip，集群中不同机器采用不用的ip，IP请求转发 四层负载 -&gt; 传输层负载，包含ip和端口，修改目标ip和端口地址 七层负载 -&gt; 应用层负载，请求的url，http请求的报文，如http://a/a.html,主机名。 tcp和udp区别TCP/IP：可靠 建立连接机制 三次握手建立连接 client发送请求连接的数据包 server返回可以进行连接的数据包 client发送确认请求连接的数据包 client/server可以进行数据传输了 SYNC攻击 -&gt; 客户端伪造大量ip和mac地址发送消息给服务器，占用服务器大量资源 连接的关闭，四次挥手协议 client发送请求关闭连接的数据包 server返回确认收到请求关闭的数据包-此时server可能还处于数据操作的状况 server数据已经处理完毕，并返回可以关闭的数据包 client返回最终请求关闭数据包-此时server接收到数据包以后将处于关闭状态,而client可能还处于数据为未接受完的状态，等待2个固定的时间点后进入关闭状态 TCP是一种全双工的协议 长连接，正常连接是超时关闭，但是长连接可以发送心跳包维持连接 UDP/IP：不可靠 在应用中如何去构建一个传输的实例socket -&gt; 套接字 socket io file io 通讯过程中的阻塞accept阻塞(连接阻塞) 流操作的阻塞(read/write) 滑动窗口的协议流量控制BIO模型 ​ blocker io 阻塞 优化方案： 可以解决socket io阻塞，但是还是存在file io阻塞问题 123456789101112131415ServerSocket server = new ServerSocket(8080);while(true) &#123; Socket socket = server.accpet(); new Thread(new SocketThread(socket)).start;&#125;public class SocketThread implements Runnable&#123; Socket socket; public SocketThread(Socket socket) &#123; this.socket = socket; &#125; public void run() &#123; // 对socket进行操作 &#125;&#125; NIO非阻塞 ​ new io / non blocker io 多路复用机制 linux fd：linux系统中一切皆可看成是文件，文件描述符是内核为了高效管理已被打开的文件所创建的索引 serverSocket 向请求内核 先监听socket/fd，再如果发现socket/fd已就绪，就发送数据已经准备好的通知(即可以像该文件进行读写)，然后serverSocket再来发送read/write请求 linux提供的io复用机制 select/poll：轮询查询socket/fd是否已经就绪 epoll：事件机制，理解为注册监听机制，如果发现socket/fd就绪直接返回就绪通知，可以进行读写 服务端的机器怎么去标记一个个的连接四元组：source_ip/source_port/target_ip/target_port 因为目标机器的ip和端口固定，所以最大连接数取决于客户端的数量 source_ip : 2^32 source_port:2^16 因为0不能作为端口，所以是65535个 内存大小 文件句柄的限制 ulimit -n 默认是1024 带宽的资源","categories":[{"name":"通讯协议","slug":"通讯协议","permalink":"https://github.com/LBraveHeart/categories/通讯协议/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://github.com/LBraveHeart/tags/网络/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"jdk8 部分新特性","slug":"java8-lambda语法","date":"2019-07-11T04:01:00.000Z","updated":"2019-07-18T02:08:31.718Z","comments":true,"path":"2019/07/11/java8-lambda语法/","link":"","permalink":"https://github.com/LBraveHeart/2019/07/11/java8-lambda语法/","excerpt":"","text":"jdk1.8 时间的创建及工具类1234567891011121314151617181920212223242526272829303132333435// ClockClock clock = Clock.systemDefaultZone();System.out.println(clock.millis());Instant instant = clock.instant();System.out.println(instant);Date from = Date.from(instant);System.out.println(from);// 时区// 获取所有时区Set&lt;String&gt; availableZoneIds = ZoneId.getAvailableZoneIds();System.out.println(availableZoneIds);// 获取指定时区的ZoneIdZoneId of = ZoneId.of(\"Asia/Aden\");System.out.println(of.getRules());// localtime 获取指定时区的时间LocalTime now = LocalTime.now(of);System.out.println(\"当前时间是：\"+now);// localData 本地日期LocalDate today = LocalDate.now();System.out.println(\"今天的日期是：\"+today);LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);System.out.println(\"明天的日期是：\"+tomorrow);LocalDate yesterday = today.plus(-1, ChronoUnit.DAYS);System.out.println(\"昨天的日期是：\"+yesterday);// 创建指定日期LocalDate of1 = LocalDate.of(2019, Month.JUNE, 11);System.out.println(of1);DayOfWeek dayOfWeek = of1.getDayOfWeek();System.out.println(\"今天是周几：\"+dayOfWeek);// DateTimeFormatter格式化时间DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy年MM月dd日\");String format = formatter.format(today);System.out.println(format); Stream12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970List&lt;String&gt; stringList = new ArrayList&lt;&gt;();stringList.add(\"ddd2\");stringList.add(\"aaa2\");stringList.add(\"bbb1\");stringList.add(\"aaa1\");stringList.add(\"bbb3\");stringList.add(\"ccc\");stringList.add(\"bbb2\");stringList.add(\"ddd1\");// stream 串行// 过滤stringList .stream() .filter(s -&gt; s.startsWith(\"a\")) .forEach(System.out::println);System.out.println(\"-----------------------\");// 排序// 排序只是创建了一个排序好的stream，原数据并没有改变stringList .stream() .sorted() .filter(s -&gt; s.startsWith(\"a\")) .forEach(System.out::println);System.out.println(\"-----------------------\");// map映射,map操作stringList .stream() .map(String::toUpperCase) .sorted((o1, o2) -&gt; o2.compareTo(o1)) .forEach(System.out::println);System.out.println(\"-----------------------\");// 匹配，任一一个匹配就可以返回boolean anyMatch = stringList .stream() .anyMatch(s -&gt; s.startsWith(\"a\"));System.out.println(anyMatch);System.out.println(\"-----------------------\");// 匹配，所有匹配，所有匹配到才会返回trueboolean allMatch = stringList .stream() .allMatch(s -&gt; s.startsWith(\"a\"));System.out.println(allMatch);System.out.println(\"-----------------------\");// 匹配,没有匹配到的返回true，如果有匹配到的则返回falseboolean noneMatch = stringList .stream() .noneMatch(s -&gt; s.startsWith(\"a\"));System.out.println(noneMatch);System.out.println(\"-----------------------\");// 计数long count = stringList .stream() .filter(s -&gt; s.startsWith(\"a\")) .count();System.out.println(count);System.out.println(\"-----------------------\");// 规约,将集合整合为一个元素Optional&lt;String&gt; reduce = stringList .stream() .sorted() .reduce((s, s2) -&gt; s + \"#\" + s2);reduce.ifPresent(System.out::println); lambda语法创建接口1234567891011public interface InteTest &#123; void initData(String string);&#125;public class Test &#123; public static void main(String[] args) &#123; InteTest inteTest = string -&gt; &#123; System.out.println(string); &#125;; inteTest.initData(\"123\"); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://github.com/LBraveHeart/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/LBraveHeart/tags/java/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"微服务及SpringCloud的一些面试问题","slug":"务及SpringCloud的一些面试问题","date":"2019-07-02T07:47:00.000Z","updated":"2019-07-03T06:17:59.538Z","comments":true,"path":"2019/07/02/务及SpringCloud的一些面试问题/","link":"","permalink":"https://github.com/LBraveHeart/2019/07/02/务及SpringCloud的一些面试问题/","excerpt":"","text":"soa和微服务的区别 soa:面向服务的框架，着重于将应用系统根据不同的业务模块拆分不同的服务，并通过这些服务定义好的接口联系起来。它是一种粗粒度，松耦合的框架，主要解决的是服务重复性问题。 微服务:微服务是soa架构下的最终产物，它相对soa来说对系统的拆分更加彻底，拆分粒度更细，拆分后的服务都可以单独的运行。微服务主要解决的是服务的高耦合问题，通过降低服务之间的耦合度来把服务分割的更彻底，每个服务都可以不依赖于其他服务而独立运行，当一个服务出问题时，对其他服务并不会造成影响。 soa和微服务都是分布式的具体实现思想。 你是怎么理解微服务的？ 微服务顾名思义就是将系统拆分为一个个可以独立部署、水平扩展、独立运行的细微服务。 使用微服务的思想通过对单体架构的系统进行细粒度的拆分，从而降低各个服务之间的耦合度，单个服务中如果出现问题而不会对其他服务产生影响。并且通过对系统的拆分，会极大的解决原单体架构系统中的有些业务运行速度过慢而对其他业务造成的影响。 什么是SpringCloud SpringCloud可以通俗的理解为整合各个分布式基础设施的工具箱，它是一系列框架的有序集合，注重于服务治理。 微服务架构的优点和缺点有哪些？ 微服务的主要作用是大型业务系统进行细粒度的拆分，从而降低项目开发时某一模块的开发对其他模块业务开发的影响，可以将项目中的各个模块更快地上线落地，相对传统的单体架构中一块出问题其他都会被影响，微服务带来的是更加敏捷的更新维护，当其中一个服务出问题时，其他服务不会受到影响。但是当系统拆分的太细致，造成的运维成本也相对的更大，梳理各服务的功能调用逻辑更麻烦，本来只需要对一个系统的维护现在变相的变成对多个系统的维护，这样的成本会大大的增大。 SpringCloud解决了什么问题？ SpringCloud利用SpringBoot的开发便利性简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、熔断器、数据监控、负载均衡等，都可以利用SpringBoot的开发风格做到一键部署和启动。","categories":[{"name":"java","slug":"java","permalink":"https://github.com/LBraveHeart/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/LBraveHeart/tags/java/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://github.com/LBraveHeart/tags/SpringCloud/"},{"name":"微服务","slug":"微服务","permalink":"https://github.com/LBraveHeart/tags/微服务/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"java并发编程-volatile关键字","slug":"latile","date":"2019-06-26T08:16:00.000Z","updated":"2019-06-26T09:36:14.152Z","comments":true,"path":"2019/06/26/latile/","link":"","permalink":"https://github.com/LBraveHeart/2019/06/26/latile/","excerpt":"","text":"并发编程MESI协议基于失效的缓存一致性协议 有四个状态: Exclusive(E)：独享，其他缓存都没有有效的副本 Shared(S)：共享，其他缓存都有有效的副本 Invalid(I)：失效 Modified(M)：修改 原子性、有序性、可见性原子性在java中，对基本数据类型的变量读取和赋值操作是原子性操作，这些操作是不可中断的，也就是要么读，要么不读，或者要么写要么不写。 1234x = 10; // 操作1y = x; // 操作2x++; // 操作3x = x + 1;//操作4 以上的操作中只有操作1属于原子性操作。 有序性有以下这样的代码：12345678910111213int x = 10;//volatile int x = 10; 如果x有volatile关键字修饰时,就可以保证有序性void cpu0()&#123; x = 100;// 此时x的状态变幻情况为：S(共享) -&gt; M(修改),此时通过cpu0会通知其他cpu的x的值为I(失效)，再取出最新值，会消耗一段时间才会将x的值修改完成 flag = true;// 当flag此时是E状态时，变化状态:E(独享) -&gt; M(修改)，此时flag的值会直接修改，并发送给其他cpu状态置为S(共享)&#125;void cpu1()&#123; while(flag) &#123; System.out.println(x == 100); &#125;&#125; 当有volatile关键字修饰时，会看到在程序运行时的汇编指令中会发现有locak指令，相当于一个内存屏障，会强制把缓存的操作写入主存。 当不能保证有序性时，打印输出的结果可能为false。所以在程序运行必须保证有序性。 可见性在Java中，提供了volatile关键保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。此外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。 volatile、synchronizedvolatile可以保证对变量操作的有序性、可见性，但是不能保证原子性 synchronized可以保证对变量的有序性、可见性、原子性","categories":[{"name":"java","slug":"java","permalink":"https://github.com/LBraveHeart/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/LBraveHeart/tags/java/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"linux的5种io模型","slug":"nux的5中io模型","date":"2019-06-11T10:27:00.000Z","updated":"2019-06-12T01:26:41.349Z","comments":true,"path":"2019/06/11/nux的5中io模型/","link":"","permalink":"https://github.com/LBraveHeart/2019/06/11/nux的5中io模型/","excerpt":"","text":"linux的5种io模型阻塞式io非阻塞式io信号驱动式ioio复用模式异步io","categories":[{"name":"linux","slug":"linux","permalink":"https://github.com/LBraveHeart/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://github.com/LBraveHeart/tags/linux/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"URL与URI的区别","slug":"RL与URI的区别","date":"2019-06-05T08:20:36.000Z","updated":"2019-07-10T03:55:46.779Z","comments":true,"path":"2019/06/05/RL与URI的区别/","link":"","permalink":"https://github.com/LBraveHeart/2019/06/05/RL与URI的区别/","excerpt":"","text":"定义URL 统一资源定位符 示例:http://localhost:8081/spring/demo/query?name=1 URI 统一资源标识符 示例:/spring/demo/query","categories":[],"tags":[],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"Arrays.asList()的使用","slug":"代码示例","date":"2019-05-29T02:44:00.000Z","updated":"2019-07-11T04:11:07.461Z","comments":true,"path":"2019/05/29/代码示例/","link":"","permalink":"https://github.com/LBraveHeart/2019/05/29/代码示例/","excerpt":"","text":"Arrays.asList()的使用代码：12345678910111213141516171819202122232425262728293031323334353637383940public class ArraysToListTest &#123; public static void main(String[] args) &#123; int[] nums = &#123;1,2,3,4,5&#125;; printArrays(nums); List&lt;int[]&gt; ints = Arrays.asList(nums); printArrays(ints); Integer[] integers = &#123;1,2,3,4,5&#125;; printArrays(integers); List&lt;Integer&gt; integerList = Arrays.asList(integers); printArrays(integerList); &#125; public static void printArrays(List list)&#123; list.forEach(o -&gt; &#123; if (o instanceof int[]) &#123; printArrays((int[]) o); &#125;else &#123; System.out.println(o); &#125; &#125;); System.out.println(); &#125; public static void printArrays(Integer[] nums)&#123; for (int i = 0; i &lt; nums.length; i++) &#123; int num = nums[i]; System.out.print(num+\" \"); &#125; System.out.println(); &#125; public static void printArrays(int[] nums)&#123; for (int i = 0; i &lt; nums.length; i++) &#123; int num = nums[i]; System.out.print(num+\" \"); &#125; System.out.println(); &#125;&#125; 总结： 当使用Arrays.asList(nums);转换的数组内容为基本数据类型时，转换后的list集合的存放的也是这个基本数据类型的数组，而不是这个基本数据类型的值。 如果要对转换后的list进行增删改操作，则需要以new的方式来创建list 解决方法：使用其包装类型: 12Integer[] integers = &#123;1,2,3,4,5&#125;;List&lt;Integer&gt; integerList = new ArrayList&lt;&gt;(Arrays.asList(integers));","categories":[{"name":"java","slug":"java","permalink":"https://github.com/LBraveHeart/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/LBraveHeart/tags/java/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"单例模式的基础知识","slug":"模式","date":"2019-05-29T01:28:00.000Z","updated":"2019-07-02T07:53:23.690Z","comments":true,"path":"2019/05/29/模式/","link":"","permalink":"https://github.com/LBraveHeart/2019/05/29/模式/","excerpt":"","text":"单例模式单例模式的优缺点优点 内存消耗小 全局只有一个实例 缺点 没有接口，扩展困难 如果要扩展单例，只能修改代码 创建单例的方法饿汉式模式 直接创建-消耗内存-线程不安全 静态创建-线程不安全 懒汉式模式 判断为空再创建-线程不安全 双重检验为空再创建 使用synchronize关键字-线程安全 静态内部类创建-线程安全 注册式创建 简单注册-spring 枚举类创建 序列化线程池关于单例模式的问题spring的单例会被回收吗？ 注册式单例，被保存在ioc的缓存容器中，给每个实例起个名字，叫beanName、id ioc容器持有单例对象的引用 当对象为null或引用不被任何地方所持有时会被回收 ioc容器本身也是个单例，ioc容器什么时候被回收，那么ioc中的beanName也就什么时候被回收 ioc容器实在spring启动时初始化，在spring销毁时被回收 spring中的单例Bean跟ioc容器同生死 spring的单例是线程安全的吗？ 它由在beanFactory中由反射机制创建，被缓存到ioc容器中，相当于new Object() 所以他是线程安全的","categories":[{"name":"java","slug":"java","permalink":"https://github.com/LBraveHeart/categories/java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/LBraveHeart/tags/设计模式/"},{"name":"单例模式","slug":"单例模式","permalink":"https://github.com/LBraveHeart/tags/单例模式/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"Java Integer(-128~127)值的==和equals比较","slug":"va-Integer-128-127-值的-和equals比较","date":"2019-05-29T01:28:00.000Z","updated":"2019-06-12T07:40:45.161Z","comments":true,"path":"2019/05/29/va-Integer-128-127-值的-和equals比较/","link":"","permalink":"https://github.com/LBraveHeart/2019/05/29/va-Integer-128-127-值的-和equals比较/","excerpt":"","text":"Integer有如下代码： 123456789101112131415161718192021222324Integer i1 = 127;Integer i2 = 127;System.out.print(i1+\" == \"+i2+\" :\"+(i1 == i2));System.out.println(\" \"+i1+\".equals(\"+i2+\") :\"+(i1.equals(i2)));Integer i3 = 128;Integer i4 = 128;System.out.print(i3+\" == \"+i4+\" :\"+(i3 == i4));System.out.println(\" \"+i3+\".equals(\"+i4+\") :\"+(i3.equals(i4)));Integer i5 = new Integer(127);Integer i6 = new Integer(127);System.out.print(i5+\" == \"+i6+\" :\"+(i5 == i6));System.out.println(\" \"+i5+\".equals(\"+i6+\") :\"+(i5.equals(i6)));Integer i7 = new Integer(128);Integer i8 = new Integer(128);System.out.print(i7+\" == \"+i8+\" :\"+(i7 == i8));System.out.println(\" \"+i7+\".equals(\"+i8+\") :\"+(i7.equals(i8)));Integer i9 = new Integer(40);Integer i10 = new Integer(40);Integer i11 = new Integer(0);System.out.println(\"i9=i10+i11 \" + (i9 == i10 + i11)); 输出结果如下： 12345127 == 127 :true 127.equals(127) :true128 == 128 :false 128.equals(128) :true127 == 127 :false 127.equals(127) :true128 == 128 :false 128.equals(128) :truei9=i10+i11 true 总结: 在-128~127的Integer值如果以Integer x = value;的方式赋值的Integer值在进行==和equals比较时，都会返回true 在-128~127之外的以Integer x = value;的方式赋值的Integer值在进行==和equals比较时，返回结果并不下相同 无论是在-128~127还是之外的Integer值如果以Integer x = new Integer(value);的方式赋值的Integer值在进行==和equals比较时,返回结果都并不x相同 因为Java里面对处在在-128~127之间的使用Integer x = value;赋值的Integer值，用的是原生数据类型int，会在内存里供重用，也就是说这之间的Integer值进行==比较时只是进行int原生数据类型的数值比较，而超出-128~127的范围，进行==比较时是进行地址及数值比较。 而对于所有以Integer x = new Integer(value);赋值的Integer值，使用== 比较时是进行地址及数值比较。 语句 i9 == i10 + i11，因为+这个操作符不适用于 Integer 对象，首先 i10 和 i11 进行自动拆箱操作，进行数值相加，即 i9 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i9 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较 所以在比较包装类型的值时，必须使用equals进行比较","categories":[{"name":"java","slug":"java","permalink":"https://github.com/LBraveHeart/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/LBraveHeart/tags/java/"},{"name":"Integer","slug":"Integer","permalink":"https://github.com/LBraveHeart/tags/Integer/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"markdown特殊语法","slug":"arkdown特殊语法","date":"2019-05-22T09:49:00.000Z","updated":"2019-05-30T04:30:12.154Z","comments":true,"path":"2019/05/22/arkdown特殊语法/","link":"","permalink":"https://github.com/LBraveHeart/2019/05/22/arkdown特殊语法/","excerpt":"","text":"插入图片1&#123;% asset_img clipboard.png 图片1 %&#125;","categories":[{"name":"工具","slug":"工具","permalink":"https://github.com/LBraveHeart/categories/工具/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://github.com/LBraveHeart/tags/markdown/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"linux命令","slug":"linux命令","date":"2019-05-15T09:52:00.000Z","updated":"2019-05-29T02:05:52.421Z","comments":true,"path":"2019/05/15/linux命令/","link":"","permalink":"https://github.com/LBraveHeart/2019/05/15/linux命令/","excerpt":"","text":"linux命令上传-下载文件上传和下载文件使用rz和sz命令 使用以下命令安装rz和sz： 1yum install -y lrzsz 上传输入以下命令： 1rz 打开选择文件窗口选择文件即可上传 下载输入以下命令：1sz 文件名 打开文件要下载的地址选择路径下载即可 ssh传输文件123scp test.zip admin@192.168.1.1:/test解析：scp 文件名 ssh地址:要复制的文件到远程机的路径 vi编辑器1234567891011121314151617181920212223242526272829303132333435打开文件：vi test.txtCtrl+u：向文件首翻半屏；Ctrl+d：向文件尾翻半屏；Ctrl+f：向文件尾翻一屏；Ctrl+b：向文件首翻一屏；Esc：从编辑模式切换到命令模式；ZZ：命令模式下保存当前文件所做的修改后退出vi；:行号：光标跳转到指定行的行首；:$：光标跳转到最后一行的行首；x或X：删除一个字符，x删除光标后的，而X删除光标前的；D：删除从当前光标到光标所在行尾的全部字符；dd：删除光标行正行内容；ndd：删除当前行及其后n-1行；nyy：将当前行及其下n行的内容保存到寄存器？中，其中？为一个字母，n为一个数字；p：粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的下方；P：粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的上方；/字符串：文本查找操作，用于从当前光标所在位置开始向文件尾部查找指定字符串的内容，查找的字符串会被加亮显示；？字符串：文本查找操作，用于从当前光标所在位置开始向文件头部查找指定字符串的内容，查找的字符串会被加亮显示；a，bs/F/T：替换文本操作，用于在第a行到第b行之间，将F字符串换成T字符串。其中，“s/”表示进行替换操作；a：在当前字符后添加文本；A：在行末添加文本；i：在当前字符前插入文本；I：在行首插入文本；o：在当前行后面插入一空行；O：在当前行前面插入一空行；:wq：在命令模式下，执行存盘退出操作；:w：在命令模式下，执行存盘操作；:w！：在命令模式下，执行强制存盘操作；:q：在命令模式下，执行退出vi操作；:q！：在命令模式下，执行强制退出vi操作；:e文件名：在命令模式下，打开并编辑指定名称的文件；:n：在命令模式下，如果同时打开多个文件，则继续编辑下一个文件；:f：在命令模式下，用于显示当前的文件名、光标所在行的行号以及显示比例；:set number：在命令模式下，用于在最左端显示行号；:set nonumber：在命令模式下，用于在最左端不显示行号；","categories":[{"name":"linux","slug":"linux","permalink":"https://github.com/LBraveHeart/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://github.com/LBraveHeart/tags/linux/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"动态壁纸","slug":"壁纸","date":"2019-05-15T07:47:00.000Z","updated":"2019-05-29T02:09:29.284Z","comments":true,"path":"2019/05/15/壁纸/","link":"","permalink":"https://github.com/LBraveHeart/2019/05/15/壁纸/","excerpt":"","text":"动态壁纸软件 Wallpaper Engine","categories":[{"name":"工具","slug":"工具","permalink":"https://github.com/LBraveHeart/categories/工具/"}],"tags":[{"name":"壁纸工具","slug":"壁纸工具","permalink":"https://github.com/LBraveHeart/tags/壁纸工具/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"opencv参考链接","slug":"pencv参考链接","date":"2019-05-06T09:18:00.000Z","updated":"2019-05-29T02:09:39.015Z","comments":true,"path":"2019/05/06/pencv参考链接/","link":"","permalink":"https://github.com/LBraveHeart/2019/05/06/pencv参考链接/","excerpt":"","text":"基于java的opencv、tesseractc参考链接 Intellij Idea 部署 OpenCV-4.0.0 环境 如何使用Tesseract和OpenCV执行OCR和文本识别 tesseract官方文档 OpenCV Java Tutorials documentation! Tesseract-OCR识别中文与训练字库实例 Tesseract-OCR识别中文与训练字库实例","categories":[{"name":"人工识别","slug":"人工识别","permalink":"https://github.com/LBraveHeart/categories/人工识别/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/LBraveHeart/tags/java/"},{"name":"ocr","slug":"ocr","permalink":"https://github.com/LBraveHeart/tags/ocr/"},{"name":"oepncv","slug":"oepncv","permalink":"https://github.com/LBraveHeart/tags/oepncv/"},{"name":"testseract","slug":"testseract","permalink":"https://github.com/LBraveHeart/tags/testseract/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"git提交","slug":"it提交","date":"2019-05-06T09:15:00.000Z","updated":"2019-05-29T02:09:45.235Z","comments":true,"path":"2019/05/06/it提交/","link":"","permalink":"https://github.com/LBraveHeart/2019/05/06/it提交/","excerpt":"","text":"git提交步骤 git init //初始化仓库 git add .(文件name) //添加文件到本地仓库 git commit -m “first commit” //添加文件描述信息 git remote add origin + 远程仓库地址 //链接远程仓库，创建主分支 git pull origin master // 把本地仓库的变化连接到远程仓库主分支 git push -u origin master //把本地仓库的文件推送到远程仓库 强制提交如果确定代码无误，可以强制提交 git push -f 错误处理1fatal: refusing to merge unrelated histories 在merge、pull或push中出现以上错误，可以使用以下命令： 12345678merge时：git merge master --allow-unrelated-historiespull时：git pull origin master --allow-unrelated-historiespush时：git push -u origin master --allow-unrelated-histories","categories":[{"name":"工具","slug":"工具","permalink":"https://github.com/LBraveHeart/categories/工具/"}],"tags":[{"name":"git","slug":"git","permalink":"https://github.com/LBraveHeart/tags/git/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"html5 audio配合span data-src-mp3使用","slug":"ntitled","date":"2019-04-26T04:20:00.000Z","updated":"2019-05-29T02:09:56.881Z","comments":true,"path":"2019/04/26/ntitled/","link":"","permalink":"https://github.com/LBraveHeart/2019/04/26/ntitled/","excerpt":"","text":"html5 audio配合span data-src-mp3使用编写html代码12345&lt;audio id=\"player\" style=\"display: none\"&gt;&lt;/audio&gt;&lt;span class = '1' data-src-mp3=\"\" data-src-ogg=\"\"&gt;&lt;/span&gt; &lt;span class = '2' data-src-mp3=\"\" data-src-ogg=\"\"&gt;&lt;/span&gt; 初始化span标签123456$(\"span.1\") .attr(\"data-src-mp3\",\"song1.mp3\") .attr(\"data-src-ogg\",\"song1.ogg\");$(\"span.2\") .attr(\"data-src-mp3\",\"song2.mp3\") .attr(\"data-src-ogg\",\"song2.ogg\"); 控制播放1234567891011121314151617181920212223$(\"span[data-src-mp3]\").click(function () &#123; var player = document.getElementById(\"player\"), $this = $(this); if ($this.hasClass(\"selected\")) &#123; if (player.paused) &#123; player.play(); &#125; else &#123; player.pause(); &#125; &#125; else &#123; $(\"span[data-src-mp3].selected\").removeClass(\"selected\"); $this.addClass(\"selected\"); $(player) .empty() .append($(\"&lt;source&gt;\").attr(\"src\", $this.attr(\"data-src-mp3\"))) .append($(\"&lt;source&gt;\").attr(\"src\", $this.attr(\"data-src-ogg\"))) // 必须使用load重新加载audio，否则播放audio时，播放出来的还是最初始的资源 player.load(); player.play(); &#125;&#125;);","categories":[{"name":"html","slug":"html","permalink":"https://github.com/LBraveHeart/categories/html/"}],"tags":[{"name":"audio","slug":"audio","permalink":"https://github.com/LBraveHeart/tags/audio/"},{"name":"html5","slug":"html5","permalink":"https://github.com/LBraveHeart/tags/html5/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"SpringBoot项目基础搭建","slug":"ringBoot","date":"2019-03-15T01:54:00.000Z","updated":"2019-07-02T07:54:13.000Z","comments":true,"path":"2019/03/15/ringBoot/","link":"","permalink":"https://github.com/LBraveHeart/2019/03/15/ringBoot/","excerpt":"","text":"什么是spring bootSpring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。 — 来自百度百科 springboot 的特点 创建独立的Spring应用程序 嵌入的Tomcat，无需部署WAR文件 简化Maven配置 自动配置Spring 提供生产就绪型功能，如指标，健康检查和外部配置 绝对没有代码生成并且对XML也没有配置要求 使用spring boot有什么好处简单、快速、方便！平时如果我们需要搭建一个spring web项目的时候需要怎么做呢？ 1）配置web.xml，加载spring和spring mvc 2）配置数据库连接、配置spring事务 3）配置加载配置文件的读取，开启注解 4）配置日志文件 … 配置完成之后部署tomcat 调试 … 快速入门maven构建项目使用工具：IntelliJ IDEA 2018.3.4、jdk1.8.0_201 在idea界面点击 Create New project,然后点击Next 选择Spring Initializar点击Next 设置初始java包结构点击Next 在此步骤选择springboot集成的其他框架，如mysql然后点击Next 输入项目名称，点击finish即可完成创建springboot项目项目结构如下： src/main/java/: 程序开发及主程序入口 src/main/resources/: 配置文件 src/test: 测试程序 引入web模块1、在pom文件中添加web模块依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; pom.xml文件中默认有两个模块： spring-boot-starter：核心模块，包括自动配置支持、日志和YAML； spring-boot-starter-test：测试模块，包括JUnit、Hamcrest、Mockito。 2、编写 HelloWorldController1234567@RestControllerpublic class HelloWorldController &#123; @RequestMapping(\"/hello\") private String hello()&#123; return \"hello world\"; &#125;&#125; @RestController的意思就是controller里面的方法都以json格式输出. 3、启动主程序在浏览器打开http://127.0.0.1:8080/hello,即可看到结果 开发环境的调试springBoot对调试支持很好，修改之后可以实时生效，需要添加以下的配置： 12345678910111213141516171819&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 该模块在完整的打包环境下运行的时候会被禁用。如果你使用java -jar启动应用或者用一个特定的classloader启动，它会认为这是一个“生产环境”。","categories":[{"name":"springboot","slug":"springboot","permalink":"https://github.com/LBraveHeart/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://github.com/LBraveHeart/tags/springboot/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"excel数据处理","slug":"xcel数据处理","date":"2019-03-14T02:57:00.000Z","updated":"2019-05-29T02:10:13.339Z","comments":true,"path":"2019/03/14/xcel数据处理/","link":"","permalink":"https://github.com/LBraveHeart/2019/03/14/xcel数据处理/","excerpt":"","text":"excel中把一列数据中第一个空格前后的内容分为两列设原内容在A列，则12B1=LEFT(A1,FIND(&quot;&quot;,A1))C1=MID(A1,FIND(&quot;&quot;,A1)+1,LEN(A1)) 在一组数据中筛选包含另一组数据的某个数据的单元 使用MATCH(A2,$B$2:$B$13,0) 公式里第三个参数的含义： 返回结果为位置，如果只需要知道是否存在则可用： IF(MATCH(A2,$B$2:$B$13,0)&gt;0,TRUE)","categories":[{"name":"工具","slug":"工具","permalink":"https://github.com/LBraveHeart/categories/工具/"}],"tags":[{"name":"excel","slug":"excel","permalink":"https://github.com/LBraveHeart/tags/excel/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"mysql删除语句使用","slug":"sql","date":"2019-03-14T02:36:00.000Z","updated":"2019-11-21T08:19:47.688Z","comments":true,"path":"2019/03/14/sql/","link":"","permalink":"https://github.com/LBraveHeart/2019/03/14/sql/","excerpt":"","text":"mysql删除语句使用1delete t from table_name t where t.id = 1 mysql 清空表数据1truncate table table_name;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://github.com/LBraveHeart/categories/数据库/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://github.com/LBraveHeart/tags/mysql/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"服务器桌面端差异","slug":"务器桌面端差异","date":"2019-03-14T02:35:00.000Z","updated":"2019-05-29T02:08:36.350Z","comments":true,"path":"2019/03/14/务器桌面端差异/","link":"","permalink":"https://github.com/LBraveHeart/2019/03/14/务器桌面端差异/","excerpt":"","text":"javax.net.ssl.SSLKeyException: RSA premaster secret error错误的解决办法： 找到jre环境的lib/ext/sunjce_provider.jar 把这个放到程序的lib下","categories":[{"name":"问题处理","slug":"问题处理","permalink":"https://github.com/LBraveHeart/categories/问题处理/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/LBraveHeart/tags/java/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"maven导出所有使用的jar包","slug":"ven","date":"2019-03-14T01:55:00.000Z","updated":"2019-06-12T06:22:28.620Z","comments":true,"path":"2019/03/14/ven/","link":"","permalink":"https://github.com/LBraveHeart/2019/03/14/ven/","excerpt":"","text":"maven导出所有使用的jar包: mvn dependency:copy-dependencies -DoutputDirectory=lib -DincludeScope=compile","categories":[{"name":"java","slug":"java","permalink":"https://github.com/LBraveHeart/categories/java/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://github.com/LBraveHeart/tags/maven/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"cmd运行java","slug":"d运行java","date":"2019-03-14T01:52:00.000Z","updated":"2019-05-29T02:10:50.924Z","comments":true,"path":"2019/03/14/d运行java/","link":"","permalink":"https://github.com/LBraveHeart/2019/03/14/d运行java/","excerpt":"","text":"用命令行编译运行带有包或使用外部jar包的情况12345编译：javac -Djava.ext.dirs=./lib Test.java 或 javac -Djava.ext.dirs=D:/javacode/lib运行：java -Djava.ext.dirs=./lib Test 将日志保存至文件中：java -Djava.ext.dirs=./lib Test &gt;&gt; log.txt","categories":[{"name":"java","slug":"java","permalink":"https://github.com/LBraveHeart/categories/java/"}],"tags":[{"name":"cmd","slug":"cmd","permalink":"https://github.com/LBraveHeart/tags/cmd/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"notepad++ 字符串匹配","slug":"tepad-字符串匹配","date":"2019-03-12T03:35:00.000Z","updated":"2019-05-29T02:11:05.730Z","comments":true,"path":"2019/03/12/tepad-字符串匹配/","link":"","permalink":"https://github.com/LBraveHeart/2019/03/12/tepad-字符串匹配/","excerpt":"","text":"匹配模式查找：a.+?da 表示查找以a开头a结尾的","categories":[{"name":"工具","slug":"工具","permalink":"https://github.com/LBraveHeart/categories/工具/"}],"tags":[{"name":"notepad++","slug":"notepad","permalink":"https://github.com/LBraveHeart/tags/notepad/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"python格式化字符串","slug":"python","date":"2019-03-12T03:33:00.000Z","updated":"2019-06-12T06:22:02.223Z","comments":true,"path":"2019/03/12/python/","link":"","permalink":"https://github.com/LBraveHeart/2019/03/12/python/","excerpt":"","text":"格式化字符串各符号表示：%d - 整数 %s - 字符串 %f - 浮点数 %x - 十六进制整数 实例print(&apos;%2d-%02d&apos; % (3, 1)) print(&apos;%.2f&apos; % 3.1415926) 解释： %后数字若为一位表示位数，如若两位，第一位是补充数字，第二位是位数 浮点数前加. %%表示转义为%","categories":[{"name":"python","slug":"python","permalink":"https://github.com/LBraveHeart/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/LBraveHeart/tags/python/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"windows特殊字符","slug":"ndows","date":"2019-03-12T03:24:00.000Z","updated":"2019-06-12T06:21:33.743Z","comments":true,"path":"2019/03/12/ndows/","link":"","permalink":"https://github.com/LBraveHeart/2019/03/12/ndows/","excerpt":"","text":"windows特殊字符版权符号：alt+169 © 拼音：版权 ©","categories":[{"name":"工具","slug":"工具","permalink":"https://github.com/LBraveHeart/categories/工具/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://github.com/LBraveHeart/tags/windows/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"docker&tomcat","slug":"cker-tomcat","date":"2019-03-12T03:08:00.000Z","updated":"2019-05-29T02:11:41.374Z","comments":true,"path":"2019/03/12/cker-tomcat/","link":"","permalink":"https://github.com/LBraveHeart/2019/03/12/cker-tomcat/","excerpt":"","text":"docker 简介 image(镜像)：对比iso镜像文件，不可操作，只能被pull下载下来使用或push将自己的镜像上传上去 container(容器): 对比iso镜像中的live cd模式，不用直接安装需要的东西即可直接使用。但是一旦容器关闭，那么在容器中安装的vim或gcc都将会被销毁。如果要保存这些，就需要将当前容器封装成自己的镜像。 repository(仓库)： 类似于git，既可以将自己在git上下载下来的代码上传上去，也可以将自己上传上去的代码下载下来。只需要有别人的镜像的名字，标签。自己也可以将自己的镜像设置为私有。 docker 启动和停止1234停止当前tomcat应用：docker-compose down启动tomcat应用：docker-compose up -d docker compose映射端口将容器的8000端口映射到宿主机上的7001端口: docker compose run -p 7001:8000 web python a.py runserver 0.0.0.0:8000 使用-p命令映射端口后，访问web应用需访问宿主机的端口7001 启动注意docker compose run启动一个容器时，如果service中有--link指定的其他服务没有运行，会先运行这些服务，–link依赖的这些服务都运行后，才会执行指定的命令。如果不想启动依赖的其他服务，可以使用--no-deps标识。docker compnse run --no-deps web python manage.py shell","categories":[{"name":"java","slug":"java","permalink":"https://github.com/LBraveHeart/categories/java/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://github.com/LBraveHeart/tags/docker/"},{"name":"tomcat","slug":"tomcat","permalink":"https://github.com/LBraveHeart/tags/tomcat/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"jfinal 文件上传特殊处理","slug":"inal","date":"2019-03-12T03:07:00.000Z","updated":"2019-06-12T06:21:18.678Z","comments":true,"path":"2019/03/12/inal/","link":"","permalink":"https://github.com/LBraveHeart/2019/03/12/inal/","excerpt":"","text":"jfinal 文件上传特殊处理如果页面中form中有enctype=&quot;multipart/form-data&quot;属性，在后台接收数据时先使用getFile，再使用getPara();","categories":[{"name":"java","slug":"java","permalink":"https://github.com/LBraveHeart/categories/java/"}],"tags":[{"name":"jfinal","slug":"jfinal","permalink":"https://github.com/LBraveHeart/tags/jfinal/"}],"author":"刘奶奶找牛奶奶买榴莲牛奶"},{"title":"js特殊用法","slug":"js特殊用法","date":"2019-03-12T03:00:00.000Z","updated":"2019-06-04T01:45:02.763Z","comments":true,"path":"2019/03/12/js特殊用法/","link":"","permalink":"https://github.com/LBraveHeart/2019/03/12/js特殊用法/","excerpt":"","text":"jquery获取jsonJS里使用 $!{string} 获取原格式的字符串； 出现此种错误时，将${} 改为$!{} 使用 js 动态元素选择器123var i=1;var head=\"head\"+i;$(\"#head\"+head+\"\"); 使用js处理双击、选中事件jquery 处理方式1$(document.body).on('mouseup',\"#content\",mouseUp); dom处理方式：1document.addEventListener(\"dblclick\", doubleClick, true); 释放鼠标处理函数123456789101112function mouseUp() &#123; var text = \"\"; if (window.getSelection) &#123; text = window.getSelection().toString(); &#125; else if (document.selection &amp;&amp; document.selection.type != \"Control\") &#123; text = document.selection.createRange().text; &#125; if (\"\" != text&amp;&amp;\" \" != text) &#123; $(\"#checkText\").val(text); layer.msg(text); &#125;&#125; js计算1234parseInt(5/2); 结果：2 舍弃小数部分，取整数Math.ceil(5/2); 结果：3 向上取整，有小时就整数加一Math.round(5/2);结果：3 四舍五入Math.floor(5/2);结果：2 向下取整 js给指定一篇文章添加行号123456789101112131415161718192021222324252627282930313233343536373839404142434445function getLineNum()&#123;var $lineNum=$(\"#lineNum\");$lineNum.empty();var rowNum=Math.round(document.getElementById(\"contentT\").scrollHeight/parseFloat($(\"#contentT\").css(\"line-height\")));console.log(\"$('.article fl').height():\"+document.getElementById(\"contentT\").scrollHeight);console.log(\"parseFloat($('.article fl').css('line-height')):\"+parseFloat($(\"#contentT\").css(\"line-height\")));console.log(rowNum);for(var i=1;i&lt;rowNum;i++)&#123; var flag=false; if(headNum&gt;1)&#123; for(var j=2;j&lt;=headNum;j++)&#123; var headId=\"head\"+j; var $headEle=$(\"#\"+headId+\"\"); var offsetTop=$headEle.position().top; var headRow=Math.round(offsetTop/parseFloat($(\"#contentT\").css(\"line-height\"))); headRow=headRow+1; if(headRow==i)&#123; flag=true; break; &#125; &#125; &#125; if(flag)&#123; if(i%5==0||i==1)&#123; $lineNum.append(\"&lt;br&gt;&lt;p&gt;\"+i+\"&lt;/p&gt;\"); &#125;else&#123; $lineNum.append(\"&lt;br&gt;&lt;br&gt;\"); &#125; &#125;else&#123; if(i%5==0)&#123; $lineNum.append(\"&lt;p&gt;\"+i+\"&lt;/p&gt;\"); &#125;else if(i==1)&#123; $lineNum.append(\"&lt;p&gt;\"+i+\"&lt;/p&gt;\"); &#125;else&#123; $lineNum.append(\"&lt;br&gt;\"); &#125; &#125;&#125;&#125;; js对象转换jquery对象dom对象dom对象转换为jquery对象：12var d=document.getElementById(\"id\"); //对象d为DOM对象var s=$(d); //对象s为Jquery对象 jquery对象转换为dom对象：123var d=document.getElementById(\"id\"); //对象d为DOM对象var s=$(d); //对象s为Jquery对象var dd=s.get(0) //对象dd为DOM对象 js随机打乱数组 123456function randomsort(a, b) &#123; return Math.random()&gt;.5 ? -1 : 1; //用Math.random()函数生成0~1之间的随机数与0.5比较，返回-1或1&#125;var arr = [1, 2, 3, 4, 5];arr.sort(randomsort); js从数组中获取指定个数的随机数据12345678910111213141516/** * 从数组中随机取指定数量的数据 * @param arr 数据 * @param count 随机数量 * @returns &#123;*&#125; */function getRandomArrayElements(arr, count) &#123; var shuffled = arr.slice(0), i = arr.length, min = i - count, temp, index; while (i-- &gt; min) &#123; index = Math.floor((i + 1) * Math.random()); temp = shuffled[index]; shuffled[index] = shuffled[i]; shuffled[i] = temp; &#125; return shuffled.slice(min);&#125; js禁止双击1&lt;body onselectstart = &quot;return false&quot; style = &#123; -moz-user-select : none &#125;&gt;&lt;/body&gt; js控制div里的滚动条12$('.dtcon').animate(&#123;scrollTop:'0px'&#125;, 200);200:滚动条移动至指定位置所需时间 ms","categories":[{"name":"html","slug":"html","permalink":"https://github.com/LBraveHeart/categories/html/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/LBraveHeart/tags/JavaScript/"}]},{"title":"form表单外不同的按钮提交到不同的url","slug":"html","date":"2019-03-08T07:24:00.000Z","updated":"2019-06-12T06:21:04.469Z","comments":true,"path":"2019/03/08/html/","link":"","permalink":"https://github.com/LBraveHeart/2019/03/08/html/","excerpt":"","text":"form表单外不同的按钮提交到不同的url1234567891011121314151617181920&lt;form hidden=\"\" id=\"form\" method=\"post\"&gt; &lt;input type=\"text\" value=\"\" name=\"rel\" id=\"rel\"&gt; &lt;input type=\"text\" value=\"\" name=\"answer\" id=\"answer\"&gt; &lt;input type=\"text\" value=\"\" name=\"curPage\" id=\"curPage\"&gt; &lt;input type=\"text\" value=\"\" name=\"examName\" id=\"examName\"&gt;&lt;/form&gt;&lt;button typr='button' id='but1' class='but1'&gt;&lt;/button&gt;&lt;button typr='button' id='but2' class='but2'&gt;&lt;/button&gt;&lt;script&gt; $(document).on('click','button.but1',function()&#123; $(\"#form\").attr(\"action\",\"url\"); $(\"#form\").submit(); &#125;) $(document).on('click','button.but1',function()&#123; $(\"#form\").attr(\"action\",\"url\"); $(\"#form\").submit(); &#125;)&lt;/script&gt;","categories":[{"name":"html","slug":"html","permalink":"https://github.com/LBraveHeart/categories/html/"}],"tags":[{"name":"html","slug":"html","permalink":"https://github.com/LBraveHeart/tags/html/"}],"author":"码农"},{"title":"Hello World","slug":"hello-world","date":"2019-03-07T02:39:24.133Z","updated":"2019-03-07T02:39:24.133Z","comments":true,"path":"2019/03/07/hello-world/","link":"","permalink":"https://github.com/LBraveHeart/2019/03/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}